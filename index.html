<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Oswald:wght@200..700&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Firebase SDK v8 (compatible with script tags) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

  <script>
    // Firebase config - your actual config
    const firebaseConfig = {
      apiKey: "AIzaSyDj5zAgTxYAXRY4mW4Zwwqi8BsNn2pX8-s",
      authDomain: "smart-list-app-fa958.firebaseapp.com",
      projectId: "smart-list-app-fa958",
      storageBucket: "smart-list-app-fa958.firebasestorage.app",
      messagingSenderId: "405519417680",
      appId: "1:405519417680:web:15005065f9e63053326c55",
      measurementId: "G-RTDRB54SBW"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    console.log('Firebase initialized successfully');
  </script>

  <title>Smart List App</title>
  <style>
    #controls {
      background: #f0f0f0;
      padding: 12px 16px;
      margin-bottom: 1rem;
    }

    .header-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 24px;
    }

    .header-center {
      display: none;
      /* Remove center section for now */
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .date-info {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 13px;
      color: #666;
      line-height: 1.3;
    }

    .week-display {
      font-weight: 500;
      color: #444;
    }

    .date-display {
      font-size: 12px;
      color: #777;
    }

    .main-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary,
    .btn-secondary,
    .btn-menu {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .btn-primary {
      background: #2196f3;
      color: white;
    }

    .btn-primary:hover {
      background: #1976d2;
    }

    .btn-secondary {
      background: #fff;
      color: #666;
      border: 1px solid #ddd;
    }

    .btn-secondary:hover {
      background: #f5f5f5;
      color: #444;
    }

    .btn-menu {
      background: transparent;
      color: #666;
      padding: 8px 12px;
      font-size: 18px;
    }

    .btn-menu:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .btn-icon {
      font-size: 16px;
      line-height: 1;
    }

    .menu-container {
      position: relative;
    }

    .dropdown-menu-main {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 160px;
      background: var(--bg);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      border-radius: 4px;
      z-index: 2000;
      overflow: hidden;
      border: 1px solid #ddd;
    }

    /* Dark mode adjustments */
    body.dark #controls {
      background: #2a2a2a;
    }

    body.dark .btn-secondary {
      background: #333;
      color: #ccc;
      border-color: #555;
    }

    body.dark .btn-secondary:hover {
      background: #444;
    }

    body.dark .btn-menu {
      color: #ccc;
    }

    body.dark .btn-menu:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.dark .date-info .week-display {
      color: #ddd;
    }

    body.dark .date-info .date-display {
      color: #aaa;
    }

    body.dark .dropdown-menu-main {
      background: #333;
      border-color: #555;
    }

    /* Mobile responsive header */
    @media (max-width: 768px) {
      #controls {
        padding: 8px 12px;
      }

      .header-container {
        justify-content: space-between;
        align-items: center;
      }

      .header-left {
        gap: 16px;
      }

      .header-right {
        gap: 6px;
      }

      .btn-primary,
      .btn-secondary {
        padding: 6px 10px;
        font-size: 12px;
        min-height: 32px;
      }

      .btn-text {
        display: none;
      }

      .btn-icon {
        font-size: 14px;
      }

      .date-info {
        font-size: 11px;
      }

      .week-display {
        font-size: 12px;
      }

      .date-display {
        font-size: 10px;
      }
    }

    @media (max-width: 480px) {
      .header-right {
        gap: 4px;
      }

      .btn-primary,
      .btn-secondary,
      .btn-menu {
        padding: 4px 8px;
        min-height: 28px;
      }

      .btn-icon {
        font-size: 12px;
      }

      .date-info {
        font-size: 10px;
      }

      .week-display {
        font-size: 11px;
      }

      .date-display {
        font-size: 9px;
      }
    }

    :root {
      --bg: #ffffff;
      --text: #000000;
      --card: #f4f4f4;
    }

    body.dark {
      --bg: #1a1a1a;
      --text: #f5f5f5;
      --card: #1e1e1e;
    }

    body {
      margin: 0;
      padding: 1rem;
      font-family: "Inter", sans-serif;
      background-color: var(--bg);
      color: var(--text);
      font-size: 14px;
    }

    #controls {
      margin-bottom: 1rem;
    }

    #list-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-auto-rows: min-content;
      gap: 1rem;
      position: relative;
    }

    /* Masonry layout enhancement */
    #list-container.masonry {
      display: block;
      position: relative;
    }

    #list-container.masonry .list {
      position: absolute;
      width: calc((100% - 3rem) / 4);
      transition: all 0.3s ease;
      box-sizing: border-box;
    }

    /* Override transition for ghost - must be more specific */
    #list-container.masonry .list.list-ghost {
      transition: none !important;
    }

    /* Disable transitions during drag operations for dragging element only */
    #list-container.masonry .list.list-dragging {
      transition: none;
      z-index: 1000;
    }

    /* Ghost element styling */
    #list-container.masonry .list.list-ghost {
      opacity: 0.3;
      pointer-events: none;
      transition: none !important;
      position: absolute !important;
      z-index: 999;
      transform: none !important;
    }

    /* List size classes */
    .list.size-1 {
      grid-column: span 1;
    }

    .list.size-2 {
      grid-column: span 2;
    }

    .list.size-3 {
      grid-column: span 3;
    }

    .list.size-4 {
      grid-column: span 4;
    }

    /*.list.size-5 { grid-column: span 5; }*/
    .list {
      background-color: var(--card);
      position: relative;
      padding: 1rem;
      border-radius: 0px;
      min-height: 150px;
      display: flex;
      flex-direction: column;
      animation: fadeInScale 0.3s ease;
      transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
      /* cursor: grab; */
    }

    .list.dragging {
      opacity: 0.3;
      cursor: grabbing;
      transition: opacity 0.2s ease;
      z-index: 1000;
    }


    .list.style3 {
      background: transparent !important;
    }

    .list.style3 .list-accent,
    .list.style3 .list-vertical-line,
    .list.style3 .list-horizontal-line {
      display: none !important;
    }

    .list.style3 .list-item,
    .list.style3 .list-item-sub {
      border-bottom: none !important;
      background: transparent !important;
      position: relative;
      padding-left: 32px !important;
      margin-bottom: 0px;
      min-height: 28px;
      display: flex;
      align-items: center;
      font-size: 15px;
    }

    .list.style3 .list-item::before {
      content: '\2022';
      /* bullet */
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #aaa;
      font-size: 15px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }

    .list.style3 .list-item-sub {
      padding-left: 48px !important;
    }

    .list.style3 .list-item-sub::before {
      content: '\25E6';
      /* small bullet */
      position: absolute;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
      color: #ccc;
      font-size: 12px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }

    .list.style3 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 36px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e0e0e0;
      border-radius: 1px;
      z-index: 1;
      display: block;
    }

    .list.style3 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }

    .list.style3 .list-item:hover::before,
    .list.style3 .list-item-sub:hover::before {
      color: #2196f3;
    }

    .list.style3 .list-item input[type="text"],
    .list.style3 .list-item-sub input[type="text"] {
      background: transparent;
      z-index: 3;
    }

    /* Workflowy-style refined */
    .list.style3 .list-item,
    .list.style3 .list-item-sub {
      border-bottom: none !important;
      background: transparent !important;
      position: relative;
      padding-left: 32px !important;
      margin-bottom: 0px;
      min-height: 28px;
      display: flex;
      align-items: center;
      font-size: 15px;
    }

    .list.style3 .list-item::before {
      content: '\2022';
      /* bullet */
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #aaa;
      font-size: 15px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }

    .list.style3 .list-item-sub {
      padding-left: 48px !important;
    }

    .list.style3 .list-item-sub::before {
      content: '\25E6';
      /* small bullet */
      position: absolute;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
      color: #ccc;
      font-size: 12px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }

    .list.style3 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 36px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e0e0e0;
      border-radius: 1px;
      z-index: 1;
      display: block;
    }

    .list.style3 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }

    .list.style3 .list-item:hover::before,
    .list.style3 .list-item-sub:hover::before {
      color: #2196f3;
    }

    .list.style3 .list-item input[type="text"],
    .list.style3 .list-item-sub input[type="text"] {
      background: transparent;
      z-index: 3;
    }

    /* Style 1: Force black text for list content in dark mode */
    body.dark .list.style1,
    body.dark .list.style1 .list-item,
    body.dark .list.style1 .list-item-sub,
    body.dark .list.style1 input[type="text"] {
      color: #000 !important;
    }

    /* Style 1 improvements: Add borders and shadows for better definition */
    .list.style1 {
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .list.style1 .list-item,
    .list.style1 .list-item-sub {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .list.style1 .list-item:hover,
    .list.style1 .list-item-sub:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }

    /* Override the general hover styles for Style 1 */
    .list.style1 .list-item:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }

    .list.style1 .list-item-sub:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }

    .list.style1 header {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .list.style1 .item-input-cont {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .list.style1 .item-input-cont:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
    }

    /* List dropdown menu: match main menu style */
    .list-dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 160px;
      background: var(--bg);
      color: var(--text);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      border-radius: 0px;
      z-index: 10001;
      /* Higher than sub-items */
      display: none;
      flex-direction: column;
      padding: 0;
      border: none;
    }

    .list-dropdown-menu.open {
      display: block !important;
    }

    .list-dropdown-menu.floating {
      position: fixed !important;
      z-index: 2147483647 !important;
      width: auto !important;
      min-width: 160px !important;
      max-width: 280px !important;
      white-space: nowrap;
      overflow-x: hidden;
    }

    .list-dropdown-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
      position: relative;
    }

    .list-dropdown-item:hover {
      background: #f0f0f0;
    }

    /* Prevent underlying content from intercepting hover while menu open */
    .list.menu-open .items,
    .list.menu-open .item-wrapper,
    .list.menu-open .list-item,
    .list.menu-open .list-item-sub {
      pointer-events: none;
    }

    .list.menu-open .list-dropdown-menu,
    .list.menu-open .list-menu-btn {
      pointer-events: auto;
    }

    @media (hover: none) and (pointer: coarse) {

      .list:hover .list-menu-btn,
      .list:hover .list-drag-handle {
        opacity: 1;
        pointer-events: auto;
      }
    }

    /* Drag handle styles */
    .list-drag-handle {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      cursor: grab;
      padding: 4px 8px;
      background: transparent;
      border-radius: 4px;
      border: none;
      z-index: 1000;
    }

    .list-drag-handle:active {
      cursor: grabbing;
    }

    .list-drag-handle .drag-lines {
      display: flex;
      flex-direction: column;
      gap: 2px;
      width: 16px;
      height: 12px;
    }

    .list-drag-handle .drag-line {
      width: 100%;
      height: 2px;
      background: #666;
      border-radius: 1px;
    }

    body.dark .list-drag-handle .drag-line {
      background: #ccc;
    }

    /* List position indicator */
    .list-position-indicator {
      position: absolute;
      top: 6px;
      left: 6px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 8px;
      z-index: 1001;
      font-family: "Inter", sans-serif;
      line-height: 1;
      min-width: 16px;
      text-align: center;
      pointer-events: none;
    }

    body.dark .list-position-indicator {
      background: rgba(255, 255, 255, 0.7);
      color: #000;
    }

    /* List style 2 drag handle styling */
    .list.style2 .list-drag-handle {
      background: white;
      border-radius: 4px;
      padding: 6px 8px;
    }

    .list.style2 .list-drag-handle .drag-line {
      background: #666;
    }

    body.dark .list.style2 .list-drag-handle {
      background: #1a1a1a;
    }

    body.dark .list.style2 .list-drag-handle .drag-line {
      background: white;
    }

    /* List style 1 - keep drag handle and button colors same in dark mode */
    body.dark .list.style1 .list-drag-handle .drag-line {
      background: #666;
      /* Same as light mode */
    }

    body.dark .list.style1 .delete-list-btn,
    body.dark .list.style1 .delete-item-btn,
    body.dark .list.style1 .list-item-sub-btn,
    body.dark .list.style1 .edit-item-btn,
    body.dark .list.style1 .expand-collapse-btn {
      background-color: transparent;
      /* Same as light mode */
      color: #666;
      /* Same as light mode */
    }

    body.dark .list.style1 .delete-list-btn:hover,
    body.dark .list.style1 .delete-item-btn:hover,
    body.dark .list.style1 .list-item-sub-btn:hover,
    body.dark .list.style1 .edit-item-btn:hover,
    body.dark .list.style1 .expand-collapse-btn:hover {
      background-color: rgba(0, 0, 0, 0.05) !important;
      /* Same as light mode */
      color: #333;
      /* Same as light mode */
    }

    /* Apply same hover background to all list styles in dark mode */
    body.dark .delete-list-btn:hover,
    body.dark .delete-item-btn:hover,
    body.dark .list-item-sub-btn:hover,
    body.dark .edit-item-btn:hover,
    body.dark .expand-collapse-btn:hover {
      background-color: rgba(0, 0, 0, 0.05) !important;
      /* Same as light mode */
    }

    .list-accent {
      display: none;
      height: 4px;
      width: 100%;
      border-radius: 2px 2px 0 0;
      margin-bottom: -4px;
      transition: background 0.3s;
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.95);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .list.drag-over {
      outline: 0px dashed #888;
    }

    .list header {
      display: flex;
      justify-content: space-between;
      /* margin: 0.25rem 0; */
      padding: 0.25rem;
      padding-left: 0.5rem;
      border-bottom: 1px solid #9996;
    }

    .list-item {
      background: transparent;
      padding: 0.25rem;
      border-radius: 0px;
      border-bottom: 1px solid #9996;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-left: 0.5rem;
    }

    .list-item-sub {
      background: transparent;
      padding: 0.25rem;
      border-radius: 0px;
      border-bottom: 1px solid #9996;
      cursor: default;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-left: 1.5rem;
      position: relative;
      z-index: 0;
      /* Ensure sub-items are below dropdowns */
    }

    .list-item input[type="text"],
    .list-item-sub input[type="text"] {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .list-item:hover {
      border-bottom: 1px solid #444;
    }

    .list-item-sub:hover {
      border-bottom: 1px solid #444;
    }

    .dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .input-area {
      min-height: 50px;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }

    .item-input-cont {
      border-bottom: 1px solid #9996;
      display: flex;
      align-items: center;
      padding: 0.25rem;
      min-height: 23px;
      padding-left: 0.5rem;
    }

    .item-input-cont:hover {
      border-bottom: 1px solid #444 !important;
    }

    .item-input {
      width: 100%;
      height: 100%;
    }

    input[type="text"] {
      background-color: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-size: 14px;
      font-family: "Inter", sans-serif;
      width: 100%;
    }

    header input {
      font-size: 28px !important;
      font-weight: 500;
      font-family: Oswald, sans-serif !important;
    }

    .list header:hover {
      border-bottom: 1px solid #444;
    }

    input::placeholder {
      color: #888;
    }

    .placeholder {
      height: 2.5rem;
      border: 0px dashed #888;
      margin: 0.25rem 0;
      border-radius: 4px;
    }

    .delete-list-btn,
    .delete-item-btn,
    .list-item-sub-btn,
    .expand-collapse-btn,
    .size-btn {
      background-color: transparent;
      border: 0;
      cursor: pointer;
      visibility: hidden;
      opacity: 0;
      transition: opacity 200ms ease-in;
    }

    .list header:hover .delete-list-btn,
    .list header:hover .size-btn,
    .list-item:hover .delete-item-btn,
    .list-item:hover .list-item-sub-btn,
    .list-item:hover .expand-collapse-btn,
    .list-item-sub:hover .delete-item-btn,
    .list-item-sub:hover .list-item-sub-btn,
    .list-item:hover .move-item-btn,
    .list-item-sub:hover .move-item-btn,
    .list-item.move-menu-open .move-item-btn,
    .list-item-sub.move-menu-open .move-item-btn {
      visibility: visible;
      opacity: 1;
    }


    .edit-item-btn {
      background-color: transparent;
      border: 0;
      cursor: pointer;
      visibility: hidden;
      opacity: 0;
      transition: opacity 200ms ease-in;
      font-size: 14px;
    }

    .list-item:hover .edit-item-btn,
    .list-item-sub:hover .edit-item-btn {
      visibility: visible;
      opacity: 1;
    }

    /* Always show expand/collapse button when item has sub-items */
    .item-wrapper:has(.sub-items:not(:empty)) .expand-collapse-btn,
    .item-wrapper.has-sub-items .expand-collapse-btn {
      visibility: visible !important;
      opacity: 1 !important;
    }

    /* Modal styles - Side Panel Approach */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.3);
      display: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-overlay.show {
      opacity: 1;
    }

    .modal {
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: 480px;
      max-width: 33vw;
      background-color: var(--bg);
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      border-left: 1px solid #ddd;
      overflow: hidden;
    }

    .modal-overlay.show .modal {
      transform: translateX(0);
    }

    body.dark .modal {
      border-left: 1px solid #444;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 20px 15px 20px;
      border-bottom: 1px solid #eee;
      flex-shrink: 0;
    }

    body.dark .modal-header {
      border-bottom: 1px solid #444;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 500;
      margin: 0;
      color: var(--text);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 4px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      color: var(--text);
      transition: background-color 0.2s;
    }

    .modal-close:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    body.dark .modal-close:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .modal-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .modal-field {
      margin-bottom: 20px;
    }

    .modal-field label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text);
      font-size: 14px;
    }

    .modal-field textarea,
    .modal-field input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
      color: var(--text);
      background-color: var(--bg);
      resize: none;
      min-height: 80px;
      box-sizing: border-box;
    }

    .modal-field textarea:focus,
    .modal-field input[type="text"]:focus {
      outline: 2px solid #2196f3;
      border-color: transparent;
    }

    body.dark .modal-field textarea,
    body.dark .modal-field input[type="text"] {
      border: 1px solid #444;
      background-color: #2a2a2a;
    }

    .modal-date-fields {
      display: flex;
      gap: 10px;
    }

    .modal-date-fields .modal-field {
      flex: 1;
      margin-bottom: 0;
    }

    .modal-checkbox-field {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal-checkbox-field input[type="checkbox"] {
      width: auto;
    }

    .modal-action-btn {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      transition: background-color 0.2s;
    }

    .modal-action-btn:hover {
      background-color: #e0e0e0;
    }

    .modal-action-btn.delete {
      background-color: #ffebee;
      color: #d32f2f;
    }

    .modal-action-btn.delete:hover {
      background-color: #ffcdd2;
    }

    .modal-content {
      margin-bottom: 20px;
    }

    .modal-input-group {
      margin-bottom: 15px;
    }

    .modal-input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      font-size: 14px;
    }

    .modal-input-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      background-color: var(--bg);
      color: var(--text);
    }

    .modal-input-group input:focus {
      outline: none;
      border-color: #2196f3;
    }

    .sub-items-section {
      margin-top: 15px;
    }

    .sub-items-section h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 500;
    }

    .sub-item-input {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
      align-items: center;
    }

    .sub-item-input input {
      flex: 1;
    }

    .sub-item-input button {
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
    }

    .sub-item-input button:hover {
      background-color: #d32f2f;
    }

    .add-sub-item-btn {
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
    }

    .add-sub-item-btn:hover {
      background-color: #388e3c;
    }

    .modal-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px 20px 20px;
      border-top: 1px solid #eee;
      flex-shrink: 0;
    }

    body.dark .modal-footer {
      border-top: 1px solid #444;
    }

    .modal-footer .left-actions {
      display: flex;
      gap: 8px;
    }

    .modal-footer .right-actions {
      display: flex;
      gap: 8px;
    }

    .modal-btn {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
      transition: all 0.2s;
    }

    .modal-btn.primary {
      background-color: #2196f3;
      color: white;
      border-color: #2196f3;
    }

    .modal-btn.primary:hover {
      background-color: #1976d2;
      border-color: #1976d2;
    }

    .modal-btn.secondary {
      background-color: var(--bg);
      color: var(--text);
    }

    .modal-btn.secondary:hover {
      background-color: #f5f5f5;
    }

    body.dark .modal-btn.secondary {
      border-color: #444;
    }

    body.dark .modal-btn.secondary:hover {
      background-color: #333;
    }

    .modal-btn.danger {
      background-color: #f44336;
      color: white;
      border-color: #f44336;
    }

    .modal-btn.danger:hover {
      background-color: #d32f2f;
      border-color: #d32f2f;
    }

    /* Responsive design for modal */
    @media (max-width: 768px) {
      .modal {
        width: 85vw;
        max-width: 85vw;
      }
    }

    @media (max-width: 480px) {
      .modal {
        width: 90vw;
        max-width: 90vw;
      }
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }

    .modal-btn.cancel {
      background-color: #f0f0f0;
      color: #333;
    }

    .modal-btn.cancel:hover {
      background-color: #e0e0e0;
    }

    .modal-btn.save {
      background-color: #2196f3;
      color: white;
    }

    .modal-btn.save:hover {
      background-color: #1976d2;
    }

    .sub-items {
      margin-left: 0;
    }

    .sub-item-input-cont {
      padding-left: 1.5rem;
      height: 36px;
      border-bottom: 1px solid #999;
      display: flex;
      align-items: center;
    }

    .sub-item-input-cont:hover {
      border-bottom: 1px solid #444 !important;
    }

    .dropdown-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
      position: relative;
    }

    .dropdown-item:hover {
      background: #f0f0f0;
    }

    .todo-checkbox {
      position: relative;
      width: 18px;
      height: 18px;
      margin: 0 10px 0 0;
      display: inline-block;
      vertical-align: middle;
      cursor: pointer;
      opacity: 0;
      z-index: 2;
    }

    .custom-checkbox {
      position: relative;
      display: inline-block;
      width: 18px;
      height: 18px;
      margin: 0 10px 0 0;
      vertical-align: middle;
    }

    .custom-checkbox-box {
      position: absolute;
      left: 0;
      top: 0;
      width: 18px;
      height: 18px;
      border: 1.5px solid #444;
      border-radius: 2px;
      background: transparent;
      box-sizing: border-box;
      pointer-events: none;
      z-index: 1;
    }

    .custom-checkbox input:checked+.custom-checkbox-box {
      border-color: #444;
      background: transparent;
    }

    .custom-checkbox input:checked+.custom-checkbox-box::after {
      content: '\2713';
      color: #444;
      font-size: 15px;
      font-weight: bold;
      position: absolute;
      left: 2px;
      top: 0px;
      line-height: 18px;
    }

    .todo-mode .list-item .item-input,
    .todo-mode .list-item-sub .item-input {
      padding-left: 0.2em;
    }

    .todo-mode .list-item input.todo-completed,
    .todo-mode .list-item-sub input.todo-completed {
      text-decoration: line-through !important;
      color: #888 !important;
    }

    /* Date mode styles */
    .date-mode .list-item {
      display: flex;
      align-items: center;
      gap: 0;
    }

    .date-mode .list-item .date-container {
      display: flex;
      align-items: center;
      gap: 0px;
      width: 58px;
      min-width: 58px;
      flex-shrink: 0;
      background-color: #fff;
      border-radius: 4px;
      padding: 1px 4px;
    }

    .date-mode .list-item .date-day,
    .date-mode .list-item .date-month {
      font-size: 12px;
      padding: 2px 4px;
      border: none;
      background: transparent;
      color: #666;
      font-weight: 500;
      text-align: center;
      cursor: pointer;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      font-family: Inter, sans-serif;
    }

    .date-mode .list-item .date-day {
      width: 24px;
    }

    .date-mode .list-item .date-month {
      width: 34px;
    }

    .date-mode .list-item .date-day:focus,
    .date-mode .list-item .date-month:focus {
      outline: 1px solid #2196f3;
      background: rgba(33, 150, 243, 0.05);
    }

    .date-mode .list-item .date-separator {
      width: 0px;
      height: 22px;
      background: #666;
      margin: 0px 4px;
      flex-shrink: 0;
    }

    .date-mode .list-item .item-content {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 2px;
      /* Reduced from 4px to 2px for tighter spacing */
    }

    .date-mode .list-item .item-input {
      flex: 1;
      margin-right: 2px;
      /* Add small margin to separate input from buttons */
    }

    /* Date mode + Todo mode combined */
    .date-mode.todo-mode .list-item .item-content {
      padding-left: 0;
      display: flex;
      align-items: center;
      gap: 2px;
      /* Reduced from 4px to 2px for consistency */
    }

    .date-mode.todo-mode .list-item .custom-checkbox {
      margin-right: 2px;
      /* Reduce margin for tighter spacing */
      order: 1;
    }

    .date-mode.todo-mode .list-item .item-input {
      order: 2;
      flex: 1;
      margin-right: 2px;
      /* Add small margin */
    }

    .date-mode.todo-mode .list-item .expand-collapse-btn,
    .date-mode.todo-mode .list-item .list-item-sub-btn,
    .date-mode.todo-mode .list-item .move-item-btn,
    .date-mode.todo-mode .list-item .edit-item-btn,
    .date-mode.todo-mode .list-item .delete-item-btn {
      order: 3;
      margin-left: 1px;
      /* Tighter button spacing */
    }

    body.dark .list-dropdown-menu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.45);
    }

    body.dark .list-dropdown-item:hover {
      background: #333;
    }

    /* Hide 'Cycle size' in list dropdown on mobile */
    @media (max-width: 600px) {
      .list-dropdown-item:first-child {
        display: none !important;
      }

      .list-dropdown-menu {
        min-width: 180px !important;
      }
    }

    /* Style 1 & 2 vertical lines for sub-items */
    .list.style1 .list-item-sub,
    .list.style2 .list-item-sub {
      position: relative;
      padding-left: 34px !important;
    }

    .list.style1 .list-item-sub::after,
    .list.style2 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 17px;
      top: -1px;
      bottom: -1px;
      width: 1px;
      background: #000;
      border-radius: 1px;
      z-index: 10;
      display: block;
    }

    /* Hide vertical line for empty sub-items that are last */
    .list.style1 .sub-items .list-item-sub.hide-line::after,
    .list.style2 .sub-items .list-item-sub.hide-line::after {
      background: transparent;
    }

    .list-item-content,
    .list-item-sub-content {
      display: flex;
      align-items: center;
      width: 100%;
    }

    .list-item-content .item-text-span,
    .list-item-content .item-input,
    .list-item-sub-content .item-text-span,
    .list-item-sub-content .item-input {
      flex: 1 1 auto;
      min-width: 0;
    }

    .list-item-content button,
    .list-item-sub-content button {
      margin-left: 4px;
      margin-right: 0;
    }

    .list-item-sub-btn,
    .edit-item-btn,
    .delete-item-btn,
    .expand-collapse-btn {
      color: inherit !important;
      background: none !important;
      border: none !important;
      box-shadow: none !important;
      outline: none !important;
      padding: 1px;
      min-width: 20px;
      min-height: 20px;
      font-size: 16px;
      transition: background 0.15s;
      margin-left: 4px;
    }

    /* Move button - hidden on desktop, same behavior as other buttons on mobile */
    .move-item-btn {
      color: inherit !important;
      background: none !important;
      border: none !important;
      box-shadow: none !important;
      outline: none !important;
      padding: 1px;
      min-width: 20px;
      min-height: 20px;
      font-size: 16px;
      transition: background 0.15s;
      margin-left: 4px;
      visibility: hidden;
      opacity: 0;
      position: relative;
      display: none;
      /* Hidden on desktop */
    }

    /* Move dropdown menu */
    .move-dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 180px;
      /* Wider to match list menus and fit text on one line */
      background: var(--bg);
      color: var(--text);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      border-radius: 0px;
      z-index: 10002;
      /* Higher than list dropdowns */
      display: none;
      flex-direction: column;
      padding: 0;
      border: 1px solid #ddd;
    }

    .move-dropdown-menu.open {
      display: block !important;
    }

    .move-dropdown-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
      position: relative;
    }

    .move-dropdown-item:hover {
      background: #f0f0f0;
    }

    body.dark .move-dropdown-menu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.45);
    }

    body.dark .move-dropdown-item:hover {
      background: #333;
    }



    .list-item-sub-btn:hover,
    .edit-item-btn:hover,
    .delete-item-btn:hover,
    .move-item-btn:hover,
    .expand-collapse-btn:hover {
      background: #f0f0f0 !important;
      color: inherit !important;
    }

    body.dark .list-item-sub-btn:hover,
    body.dark .edit-item-btn:hover,
    body.dark .delete-item-btn:hover,
    body.dark .move-item-btn:hover,
    body.dark .expand-collapse-btn:hover {
      background: rgba(255, 255, 255, 0.1) !important;
      color: inherit !important;
    }

    /* Mobile tap highlighting */
    .list-item.mobile-selected,
    .list-item-sub.mobile-selected {
      background-color: rgba(33, 150, 243, 0.1) !important;
      border-bottom: 1px solid rgba(33, 150, 243, 0.3) !important;
    }

    .list-item.mobile-selected .delete-item-btn,
    .list-item.mobile-selected .list-item-sub-btn,
    .list-item.mobile-selected .edit-item-btn,
    .list-item.mobile-selected .move-item-btn,
    .list-item.mobile-selected .expand-collapse-btn,
    .list-item-sub.mobile-selected .delete-item-btn,
    .list-item-sub.mobile-selected .edit-item-btn,
    .list-item-sub.mobile-selected .move-item-btn {
      visibility: visible !important;
      opacity: 1 !important;
    }

    body.dark .list-item.mobile-selected,
    body.dark .list-item-sub.mobile-selected {
      background-color: rgba(33, 150, 243, 0.2) !important;
      border-bottom: 1px solid rgba(33, 150, 243, 0.4) !important;
    }

    body.dark .list.style2 .list-item-sub::after {
      background: #fff !important;
    }

    /* Mobile */
    @media (max-width: 768px) {
      #list-container {
        display: block;
        overflow-x: unset;
        scroll-snap-type: none;
      }

      .list {
        min-width: unset;
        flex-shrink: unset;
        scroll-snap-align: unset;
        margin-bottom: 1rem;
      }

      /* Hide drag handle on mobile */
      .list-drag-handle {
        display: none !important;
      }

      /* Hide masonry toggle on mobile */
      #masonry-toggle {
        display: none !important;
      }

      /* Show move button on mobile when selected */
      .move-item-btn {
        display: block !important;
        /* Override desktop display:none */
      }

      /* Hide drag cursor on mobile */
      .list-item {
        cursor: default !important;
      }

      #style-buttons {
        display: none !important;
      }

      #listrowstext,
      #rowbuttons {
        display: none !important;
      }

      /* Make all control buttons consistent size on mobile */
      #controls button {
        padding: 10px 16px !important;
        font-size: 14px !important;
        margin-right: 2px !important;
        height: auto !important;
        min-height: 40px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }

      /* Ensure menu button is also consistent */
      #menu-button-top {
        padding: 8px 12px !important;
        font-size: 18px !important;
        min-height: 40px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
    }

    .list.list-dragging {
      opacity: 0.8;
      transform: scale(0.95);
      transition: none;
      z-index: 9999;
      pointer-events: none;
      position: fixed;
      /* Will be positioned by JavaScript */
    }

    .list-placeholder {
      background: rgba(0, 0, 0, 0.1) !important;
      border: 2px dashed #999 !important;
      border-radius: 4px !important;
      opacity: 0.8;
    }

    body.dark .list-placeholder {
      background: rgba(255, 255, 255, 0.1) !important;
      border-color: #666 !important;
    }

    .has-submenu:hover .submenu {
      display: block !important;
    }

    .submenu {
      display: none;
      position: absolute;
      min-width: 140px;
      background: var(--bg);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      border-radius: 0px;
      z-index: 2100;
    }

    .submenu-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 15px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
    }

    .submenu-item:hover {
      background: #f0f0f0;
    }

    body.dark .submenu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.45);
    }

    body.dark .submenu-item:hover {
      background: #232323;
    }

    .list-ghost {
      opacity: 0.3 !important;
      pointer-events: none;
      transform: none !important;
      position: relative !important;
      left: auto !important;
      top: auto !important;
    }

    #header-topleft {
      font-size: 28px;
      font-weight: 500;
      font-family: "Oswald", sans-serif;
      color: var(--text);
      padding: 0.25rem;
      padding-left: 0.5rem;
    }
  </style>
</head>

<body>
  <!-- Body content stays the same as it was before -->

  <div id="controls">
    <div class="header-container">
      <div class="header-left">
        <div class="date-info">
          <span id="current-week" class="week-display"></span>
          <span id="current-date" class="date-display"></span>
        </div>
      </div>

      <div class="header-right">
        <button id="add-list" class="btn-primary">
          <span class="btn-icon">+</span>
          <span class="btn-text">Add List</span>
        </button>
        <button id="toggle-dark" class="btn-secondary">
          <span class="btn-icon">🌙</span>
          <span class="btn-text">Dark</span>
        </button>
        <div class="menu-container">
          <button id="menu-button-top" class="btn-menu">⋯</button>
          <div id="dropdown-menu" class="dropdown-menu-main">
            <div class="dropdown-item">Import/Export</div>
            <div class="dropdown-item">Settings</div>
            <div class="dropdown-item" id="masonry-toggle">Masonry Layout</div>
            <div class="dropdown-item">Help</div>
            <div class="dropdown-item" id="clear-empty-lists">Clear Empty Lists</div>
            <div class="dropdown-item" id="clear-data">Clear Data</div>
            <div class="dropdown-item" id="styles-menu-item">Styles ▸</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="list-container"></div>

  <!-- Edit Modal -->
  <div id="edit-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Edit Item</h3>
        <button class="modal-close" onclick="closeEditModal()">×</button>
      </div>

      <div class="modal-content">
        <div class="modal-field">
          <label for="modal-item-text">Item Text</label>
          <textarea id="modal-item-text" placeholder="Enter your item text here..."></textarea>
        </div>

        <div class="modal-combined-row" style="display: flex; gap: 20px; align-items: end; margin-bottom: 20px;">
          <div id="modal-date-section" class="modal-field" style="display: none; margin-bottom: 0; flex: 1;">
            <label>Date</label>
            <div class="modal-date-fields">
              <div class="modal-field">
                <select id="modal-day" class="modal-date-input">
                  <!-- Options will be populated by JavaScript -->
                </select>
              </div>
              <div class="modal-field">
                <select id="modal-month" class="modal-date-input">
                  <!-- Options will be populated by JavaScript -->
                </select>
              </div>
            </div>
          </div>

          <div id="modal-todo-section" class="modal-field" style="display: none; margin-bottom: 0;">
            <div class="modal-checkbox-field">
              <input type="checkbox" id="modal-todo-completed">
              <label for="modal-todo-completed">Mark as completed</label>
            </div>
          </div>
        </div>

        <!-- Action buttons directly after content -->
        <div class="modal-actions"
          style="display: flex; justify-content: space-between; align-items: center; padding-top: 20px; border-top: 1px solid #eee; margin-top: 20px;">
          <div class="left-actions">
            <button class="modal-btn danger" onclick="deleteCurrentItem()">Delete</button>
          </div>
          <div class="right-actions" style="display: flex; gap: 8px;">
            <button class="modal-btn secondary" onclick="closeEditModal()">Cancel</button>
            <button class="modal-btn primary" onclick="saveEditModal()">Save</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Styles submenu, positioned absolutely next to dropdown -->
  <div class="submenu" id="styles-submenu"
    style="display:none; position: absolute; min-width: 140px; background: var(--bg); box-shadow: 0 4px 16px rgba(0,0,0,0.15); border-radius: 0px; z-index: 2100;">
    <div class="submenu-item" id="style-one">Style 1</div>
    <div class="submenu-item" id="style-two">Style 2</div>
    <div class="submenu-item" id="style-three">Style 3</div>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script>
    // Complete JavaScript restoration
    const container = document.getElementById("list-container");
    const addListBtn = document.getElementById("add-list");
    const toggleDark = document.getElementById("toggle-dark");

    let draggedItem = null;
    const placeholder = document.createElement("div");
    placeholder.className = "placeholder";

    let isMobile = window.innerWidth <= 768;

    // Global drag state flag - must be accessible by all drag-related functions
    let isDragInProgress = false;

    // Initialize dynamic date/week display
    function updateDateDisplay() {
      const now = new Date();

      // Get week number
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const pastDaysOfYear = (now - startOfYear) / 86400000;
      const weekNumber = Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);

      // Format date
      const options = {
        weekday: 'short',
        month: 'short',
        day: 'numeric'
      };
      const dateString = now.toLocaleDateString('en-US', options);

      // Update display
      document.getElementById('current-week').textContent = `Week ${weekNumber}`;
      document.getElementById('current-date').textContent = dateString;
    }

    // This will be called from DOMContentLoaded
    let currentStyle = 1;

    function applyCurrentStyleToAllLists() {
      const lists = document.querySelectorAll('.list');
      lists.forEach(list => {
        list.classList.remove('style3', 'style1', 'style2');
        let accent = list.querySelector('.list-accent');
        if (!accent) {
          accent = document.createElement('div');
          accent.className = 'list-accent';
          list.insertBefore(accent, list.firstChild);
        }
        if (currentStyle === 1) {
          list.classList.add('style1');
          if (list.hasAttribute('data-original-bg')) {
            list.style.backgroundColor = list.getAttribute('data-original-bg');
          } else {
            const color = getRandomColor();
            list.setAttribute('data-original-bg', color);
            list.style.backgroundColor = color;
          }
          accent.style.display = 'none';
        } else if (currentStyle === 2) {
          list.classList.add('style2');
          if (!list.hasAttribute('data-original-bg')) {
            list.setAttribute('data-original-bg', list.style.backgroundColor);
          }
          list.style.backgroundColor = 'transparent';
          accent.style.display = 'block';
          accent.style.background = list.getAttribute('data-original-bg') || '#ccc';
        } else if (currentStyle === 3) {
          list.style.backgroundColor = 'transparent';
          accent.style.display = 'none';
          list.classList.add('style3');
        }
      });
    }

    document.getElementById('style-one').addEventListener('click', function () {
      currentStyle = 1;
      applyCurrentStyleToAllLists();
      autoSave(); // Save style preference
    });
    document.getElementById('style-two').addEventListener('click', function () {
      currentStyle = 2;
      applyCurrentStyleToAllLists();
      autoSave(); // Save style preference
    });
    document.getElementById('style-three').addEventListener('click', function () {
      currentStyle = 3;
      applyCurrentStyleToAllLists();
      autoSave(); // Save style preference
    });

    toggleDark.addEventListener("click", () => {
      document.body.classList.toggle("dark");
      autoSave(); // Save dark mode preference
    });

    addListBtn.addEventListener("click", () => {
      createList();
      autoSave(); // Save when new list is created
    });

    // Clear data functionality
    document.getElementById('clear-data').addEventListener('click', function () {
      if (confirm('Are you sure you want to clear all data? This will delete all your lists and cannot be undone.')) {
        clearAllData();
      }
    });

    // Function to clear all data from both localStorage and Firebase
    async function clearAllData() {
      try {
        // Set flag to prevent Firebase from loading data back
        isClearing = true;

        // Clear localStorage first
        localStorage.clear();
        localStorage.removeItem('firebaseLoadedOnce'); // Clear reload flag only when clearing data

        // Clear Firebase data if user is authenticated
        if (userId && firebaseEnabled) {
          console.log('Clearing Firebase data for user:', userId);
          await firebase.firestore()
            .collection('users')
            .doc(userId)
            .delete();
          console.log('Firebase data cleared');
        }

        // Reload page to default state
        location.reload();
      } catch (error) {
        console.error('Error clearing data:', error);
        // Still reload even if Firebase clear failed
        location.reload();
      }
    }

    function getRandomColor(prevColor = null) {
      const colors = ["#f7d6d0", "#ffb6cb", "#e5e1ea", "#b3d8fa", "#b7e5dd", "#fcf3ab"];
      let availableColors = colors;
      if (prevColor && colors.includes(prevColor)) {
        availableColors = colors.filter(c => c !== prevColor);
      }
      return availableColors[Math.floor(Math.random() * availableColors.length)];
    }

    function createList() {
      const list = document.createElement("div");
      list.className = "list size-1";

      let prevColor = null;
      const lists = document.querySelectorAll('.list');
      if (lists.length > 0) {
        const lastList = lists[lists.length - 1];
        prevColor = lastList.getAttribute('data-original-bg') || lastList.style.backgroundColor;
      }

      let accent = document.createElement('div');
      accent.className = 'list-accent';
      list.insertBefore(accent, list.firstChild);

      if (currentStyle === 1) {
        const newColor = getRandomColor(prevColor);
        list.setAttribute('data-original-bg', newColor);
        list.style.backgroundColor = newColor;
        accent.style.display = 'none';
        list.classList.add('style1');
      } else if (currentStyle === 2) {
        const newColor = getRandomColor(prevColor);
        list.setAttribute('data-original-bg', newColor);
        list.style.backgroundColor = 'transparent';
        accent.style.display = 'block';
        accent.style.background = newColor;
        list.classList.add('style2');
      } else if (currentStyle === 3) {
        const newColor = getRandomColor(prevColor);
        list.setAttribute('data-original-bg', newColor);
        list.style.backgroundColor = 'transparent';
        accent.style.display = 'none';
        list.classList.add('style3');
      }

      const header = document.createElement("header");
      header.className = "list-title";
      header.innerHTML = `
      <div style="display: flex; align-items: center; gap: 8px; width: 100%; position: relative;">
        <input type="text" placeholder="List Title" class="title-input" style="flex: 1; padding-right: 40px;" />
        <div style="position: absolute; right: 0; top: 50%; transform: translateY(-50%);">
          <button class="list-menu-btn" type="button" style="background: none; border: none; font-size: 22px; color: #444; cursor: pointer;">
            <span class="material-icons">more_horiz</span>
          </button>
          <div class="list-dropdown-menu">
            <div class="list-dropdown-item cycle-size-toggle">Cycle size</div>
            <div class="list-dropdown-item change-color-toggle">Change color</div>
            <div class="list-dropdown-item todo-mode-toggle">Todo-mode</div>
            <div class="list-dropdown-item date-mode-toggle">Date-mode</div>
            <div class="list-dropdown-item export-list-toggle">Export list</div>
            <div class="list-dropdown-item delete-list-toggle">Delete list</div>
          </div>
        </div>
      </div>
    `;

      // Add drag handle
      const dragHandle = document.createElement("div");
      dragHandle.className = "list-drag-handle";
      dragHandle.innerHTML = `
      <div class="drag-lines">
        <div class="drag-line"></div>
        <div class="drag-line"></div>
        <div class="drag-line"></div>
      </div>
    `;

      // Add position indicator
      const positionIndicator = document.createElement("div");
      positionIndicator.className = "list-position-indicator";
      positionIndicator.textContent = "1";

      const itemContainer = document.createElement("div");
      itemContainer.className = "items";

      const inputField = document.createElement("input");
      inputField.type = "text";
      inputField.placeholder = "Add item and press Enter";
      inputField.className = "item-input";

      function tryAddItem() {
        const text = inputField.value.trim();
        if (text !== "") {
          const newItem = createItem(text);
          itemContainer.appendChild(newItem);

          // If list is in todo mode, add checkbox to the new item
          const list = inputField.closest('.list');
          if (list && list.classList.contains('todo-mode')) {
            const newItemElement = newItem.querySelector('.list-item');
            if (newItemElement && !newItemElement.querySelector('.custom-checkbox')) {
              addCheckboxToItem(newItemElement);
            }
          }

          // If list is in date mode, add date input to the new item
          if (list && list.classList.contains('date-mode')) {
            const newItemElement = newItem.querySelector('.list-item');
            if (newItemElement && !newItemElement.querySelector('.date-container')) {
              addDateInputToItem(newItemElement);
            }
          }

          inputField.value = "";
          refreshLayout(); // Refresh masonry layout when item is added
          autoSave(); // Save when new item is added
        }
      }

      inputField.addEventListener("keydown", (e) => {
        if (e.key === "Enter") tryAddItem();
      });

      inputField.addEventListener("blur", () => tryAddItem());

      const outerInputContainer = document.createElement("div");
      outerInputContainer.className = "input-area";

      const inputWrapper = document.createElement("div");
      inputWrapper.className = "item-input-cont";
      inputWrapper.appendChild(inputField);
      outerInputContainer.appendChild(inputWrapper);

      list.appendChild(header);
      list.appendChild(itemContainer);
      list.appendChild(outerInputContainer);
      list.appendChild(dragHandle); // Add drag handle to list
      list.appendChild(positionIndicator); // Add position indicator to list

      // Add auto-save to title input
      const titleInput = list.querySelector('.title-input');
      if (titleInput) {
        titleInput.addEventListener('blur', () => {
          autoSave(); // Save when user finishes editing title
        });
      }

      container.appendChild(list);

      addDragListenersForList(list);
      addListDragListeners(list, dragHandle); // Add list drag functionality

      // Update position indicators for all lists
      updateListPositions();

      // Refresh masonry layout if enabled
      refreshLayout();

      return list; // Return the created list element
    }

    // Update the visual position of the dragged list to follow the mouse
    function updateListPosition(x, y) {
      if (!isDragging || !list) return;

      // Update the dragged list position to follow the mouse
      const rect = container.getBoundingClientRect();
      const offsetX = x - rect.left - (list.offsetWidth / 2);
      const offsetY = y - rect.top - 20; // Small offset from cursor

      list.style.left = Math.max(0, offsetX) + 'px';
      list.style.top = Math.max(0, offsetY) + 'px';
    }

    // RESPONSIVE collision detection - optimized but not throttled
    function getListAfterElement(container, x, y, draggedList) {
      const draggableElements = [...container.querySelectorAll('.list')];

      // Remove BOTH the dragging list AND the ghost from consideration
      const filteredElements = draggableElements.filter(el =>
        !el.classList.contains('list-dragging') &&
        !el.classList.contains('list-ghost')
      );

      let bestMatch = null;
      let bestDistance = Infinity;

      // Find the closest list to the mouse position for more stable targeting
      for (const element of filteredElements) {
        const rect = element.getBoundingClientRect();

        // Calculate center point of the element
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate distance from mouse to center
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

        // Moderate hit area - not too large to avoid conflicts
        const expandedRect = {
          left: rect.left - 15,
          right: rect.right + 15,
          top: rect.top - 15,
          bottom: rect.bottom + 15
        };

        // If mouse is within expanded area and this is the closest element
        if (x >= expandedRect.left && x <= expandedRect.right &&
          y >= expandedRect.top && y <= expandedRect.bottom &&
          distance < bestDistance) {
          bestMatch = element;
          bestDistance = distance;
        }
      }

      return bestMatch;
    }

    // Add list drag functionality - position-based swapping
    function addListDragListeners(list, dragHandle) {
      let isDragging = false;
      let startX, startY;
      let dragThreshold = 8;
      let lastTargetElement = null;
      let originalPosition = null;
      let ghostElement = null;
      let originalIndex = -1;
      let currentTargetElement = null; // Track current target to prevent flickering

      dragHandle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();

        startX = e.clientX;
        startY = e.clientY;
        isDragging = false;
        lastTargetElement = null;
        currentTargetElement = null;

        const handleMouseMove = (e) => {
          const deltaX = Math.abs(e.clientX - startX);
          const deltaY = Math.abs(e.clientY - startY);

          if (!isDragging && (deltaX > dragThreshold || deltaY > dragThreshold)) {
            isDragging = true;
            isDragInProgress = true; // Disable auto-save during drag

            // Store original position and index
            originalPosition = list.nextSibling;
            const allLists = [...container.querySelectorAll('.list')];
            originalIndex = allLists.indexOf(list);

            // Create ghost
            ghostElement = list.cloneNode(true);
            ghostElement.classList.add('list-ghost');
            ghostElement.classList.remove('list-dragging');
            const cleanGhost = ghostElement.cloneNode(true);
            container.insertBefore(cleanGhost, list);
            ghostElement = cleanGhost;

            list.classList.add('list-dragging');
            document.body.style.cursor = 'grabbing';

            // Initial masonry update when drag starts
            if (container.classList.contains('masonry')) {
              // DON'T add 'dragging' class to container - it makes all lists transparent
              cleanupMasonryTimeouts(); // Clean up any existing timeouts
              lastGhostPosition = null; // Reset position tracking
              // OPTIMIZED masonry with heavy throttling
              requestAnimationFrame(() => {
                applyMasonryLayoutDuringDragOptimized();
              });
            }

            updateListPosition(e.clientX, e.clientY);
          }

          if (isDragging) {
            updateListPosition(e.clientX, e.clientY);

            const targetElement = getListAfterElement(container, e.clientX, e.clientY, list);

            // Add stability to prevent flickering - require element to be hovered for 50ms
            if (targetElement !== currentTargetElement && targetElement !== null) {
              // Check if this element has been stable
              if (!targetElement.hasAttribute('data-hover-time')) {
                targetElement.setAttribute('data-hover-time', Date.now());
                return; // Wait for stability
              }

              const hoverTime = Date.now() - parseInt(targetElement.getAttribute('data-hover-time'));
              if (hoverTime < 100) { // 100ms stability requirement - balanced responsiveness
                return; // Not stable enough yet
              }

              // Clear hover times from all elements
              container.querySelectorAll('.list[data-hover-time]').forEach(el => {
                el.removeAttribute('data-hover-time');
              });

              currentTargetElement = targetElement;

              // Position-based swapping logic
              const allLists = [...container.querySelectorAll('.list:not(.list-dragging)')];
              const targetIndex = allLists.indexOf(targetElement);
              const ghostIndex = allLists.indexOf(ghostElement);

              if (targetIndex !== -1 && ghostIndex !== -1) {
                if (targetIndex < ghostIndex) {
                  // Moving to earlier position - insert ghost before target
                  container.insertBefore(ghostElement, targetElement);
                  // Ghost moved before target
                } else {
                  // Moving to later position - insert ghost after target
                  container.insertBefore(ghostElement, targetElement.nextSibling);
                  // Ghost moved after target
                }

                // Real-time masonry update during drag - HEAVILY THROTTLED to prevent lag
                if (container.classList.contains('masonry')) {
                  const currentGhostIndex = allLists.indexOf(ghostElement);

                  // Only trigger masonry if ghost moved to a different index
                  if (lastGhostPosition !== currentGhostIndex) {
                    lastGhostPosition = currentGhostIndex;

                    // OPTIMIZED masonry with heavy throttling
                    applyMasonryLayoutDuringDragOptimized();
                  }
                }
              }
            }
          }
        };

        const handleMouseUp = () => {
          if (isDragging) {
            list.classList.remove('list-dragging');
            list.style.position = '';
            list.style.left = '';
            list.style.top = '';
            list.style.transform = '';

            // Move the dragged list to where the ghost was positioned
            container.insertBefore(list, ghostElement);

            if (ghostElement && ghostElement.parentNode) {
              ghostElement.remove();
            }

            // Update position indicators after drag
            updateListPositions();

            // AGGRESSIVE CLEANUP - Stop all masonry calculations immediately
            cleanupMasonryTimeouts();

            // Final masonry update after drag ends
            if (container.classList.contains('masonry')) {
              // Immediate cleanup and layout to match preview
              cleanupMasonryTimeouts();

              console.log('🎯 FINAL: About to apply final masonry layout');
              const finalLists = container.querySelectorAll('.list:not(.list-dragging):not(.list-ghost)');
              console.log('🎯 FINAL: Processing lists:', Array.from(finalLists).map(l => l.querySelector('.title-input')?.value || 'untitled'));

              // Use EXACT same function as drag preview for perfect consistency
              performOptimizedMasonryDuringDrag(); // Same function, same result
            }

            // Re-enable auto-save and trigger one save after drag completes
            isDragInProgress = false;
            autoSave(); // Save the final position
          }

          document.body.style.cursor = '';
          isDragging = false;
          lastTargetElement = null;
          currentTargetElement = null;
          originalPosition = null;
          originalIndex = -1;
          ghostElement = null;

          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };

        const updateListPosition = (clientX, clientY) => {
          const offsetX = list.offsetWidth / 2;
          const offsetY = list.offsetHeight / 2;

          list.style.left = (clientX - offsetX) + 'px';
          list.style.top = (clientY - offsetY) + 'px';
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      });

      dragHandle.addEventListener('selectstart', (e) => e.preventDefault());
      dragHandle.addEventListener('dragstart', (e) => e.preventDefault());
    }

    function createItem(text = "") {
      const wrapper = document.createElement('div');
      wrapper.className = 'item-wrapper';

      const item = document.createElement("div");
      item.className = "list-item";
      item.setAttribute("draggable", true);

      const subContainer = document.createElement("div");
      subContainer.className = "sub-items";

      const input = document.createElement('input');
      input.type = 'text';
      input.value = text;
      input.className = 'item-input';
      input.title = text;
      input.addEventListener('input', () => {
        input.title = input.value;

        // Add checkbox if in todo mode and input has content
        const list = item.closest('.list');
        if (list && list.classList.contains('todo-mode') && input.value.trim() !== '' && !item.querySelector('.custom-checkbox')) {
          addCheckboxToItem(item);
        }
      });

      input.addEventListener('blur', () => {
        autoSave(); // Save when user finishes editing an item
      });
      item.appendChild(input);

      // Add buttons in consistent order: expand/collapse, plus, move, edit, delete
      const expandBtn = document.createElement('button');
      expandBtn.className = 'expand-collapse-btn';
      expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
      expandBtn.style.display = 'none'; // Initially hidden
      expandBtn.onclick = function (e) {
        e.stopPropagation();
        if (subContainer.style.display === "none") {
          subContainer.style.display = "";
          expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_down</span>";
        } else {
          subContainer.style.display = "none";
          expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
        }
        autoSave(); // Save the collapsed/expanded state
      };
      item.appendChild(expandBtn);

      const plusBtn = document.createElement('button');
      plusBtn.className = 'list-item-sub-btn';
      plusBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>add</span>";
      plusBtn.onclick = function () { addSubItem(item); };
      item.appendChild(plusBtn);

      const moveBtn = document.createElement('button');
      moveBtn.className = 'move-item-btn';
      moveBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>open_with</span>";
      moveBtn.onclick = function (e) {
        e.stopPropagation();
        toggleMoveDropdown(moveBtn);
      };

      // Create move dropdown menu with proper event delegation
      const moveDropdown = document.createElement('div');
      moveDropdown.className = 'move-dropdown-menu';

      // Create dropdown items with direct click handlers (bypass event delegation)
      const topItem = document.createElement('div');
      topItem.className = 'move-dropdown-item';
      topItem.textContent = 'Move to top of list';
      topItem.onclick = function (e) {
        e.stopPropagation();
        console.log('🔥 TOP CLICKED DIRECTLY');
        performMoveAction('top', moveBtn);
      };

      const upItem = document.createElement('div');
      upItem.className = 'move-dropdown-item';
      upItem.textContent = 'Move up one row';
      upItem.onclick = function (e) {
        e.stopPropagation();
        console.log('🔥 UP CLICKED DIRECTLY');
        performMoveAction('up', moveBtn);
      };

      const downItem = document.createElement('div');
      downItem.className = 'move-dropdown-item';
      downItem.textContent = 'Move down one row';
      downItem.onclick = function (e) {
        e.stopPropagation();
        console.log('🔥 DOWN CLICKED DIRECTLY');
        performMoveAction('down', moveBtn);
      };

      const bottomItem = document.createElement('div');
      bottomItem.className = 'move-dropdown-item';
      bottomItem.textContent = 'Move to bottom of list';
      bottomItem.onclick = function (e) {
        e.stopPropagation();
        console.log('🔥 BOTTOM CLICKED DIRECTLY');
        performMoveAction('bottom', moveBtn);
      };

      moveDropdown.appendChild(topItem);
      moveDropdown.appendChild(upItem);
      moveDropdown.appendChild(downItem);
      moveDropdown.appendChild(bottomItem);

      moveBtn.appendChild(moveDropdown);
      item.appendChild(moveBtn);

      const editBtn = document.createElement('button');
      editBtn.className = 'edit-item-btn';
      editBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>edit</span>";
      editBtn.onclick = function () { window.openEditModal(item); };
      item.appendChild(editBtn);

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-item-btn';
      deleteBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>close</span>";
      deleteBtn.onclick = function () {
        wrapper.remove();
        autoSave(); // Save when item is deleted
      };
      item.appendChild(deleteBtn);

      wrapper.appendChild(item);
      wrapper.appendChild(subContainer);

      // Function to update expand/collapse button visibility and state
      function updateExpandButton() {
        if (subContainer.children.length > 0) {
          expandBtn.style.display = 'inline';
          wrapper.classList.add('has-sub-items');
          // Check if sub-items are currently collapsed
          if (subContainer.style.display === 'none') {
            expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
          } else {
            expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_down</span>";
            subContainer.style.display = '';
          }
        } else {
          expandBtn.style.display = 'none';
          wrapper.classList.remove('has-sub-items');
          subContainer.style.display = '';
        }
      }

      // Store reference to update function for use when sub-items are added/removed
      wrapper.updateExpandButton = updateExpandButton;

      // Initial update
      updateExpandButton();

      addDragListenersForItem(item);
      return wrapper;
    }

    function addDragListenersForItem(item) {
      item.addEventListener("dragstart", (e) => {
        draggedItem = item.parentElement;
        item.parentElement.classList.add("dragging");
        isDragInProgress = true; // Disable auto-save during item drag

        // Don't add dragging class to container in masonry mode - it affects all lists
      });

      item.addEventListener("dragend", () => {
        item.parentElement.classList.remove("dragging");
        draggedItem = null;
        placeholder.remove();

        // Re-enable masonry transitions and refresh layout
        const container = document.getElementById('list-container');
        if (container.classList.contains('masonry')) {
          cleanupMasonryTimeouts(); // Clean up timeouts
          setTimeout(() => refreshLayout(), 50); // Small delay to ensure DOM is updated
        }

        // Re-enable auto-save and trigger one save after item drag completes
        isDragInProgress = false;
        autoSave(); // Save the final position
      });
    }

    function addDragListenersForList(list) {
      const itemContainer = list.querySelector(".items");

      itemContainer.addEventListener("dragover", (e) => {
        e.preventDefault();
        if (!draggedItem) return;

        const afterElement = getDragAfterElement(itemContainer, e.clientY);
        if (afterElement == null) {
          itemContainer.appendChild(placeholder);
        } else {
          itemContainer.insertBefore(placeholder, afterElement);
        }
      });

      list.addEventListener("dragover", (e) => {
        e.preventDefault();
        list.classList.add("drag-over");
      });

      list.addEventListener("dragleave", () => {
        list.classList.remove("drag-over");
      });

      list.addEventListener("drop", (e) => {
        e.preventDefault();
        list.classList.remove("drag-over");
        if (draggedItem) {
          const afterElement = getDragAfterElement(itemContainer, e.clientY);

          // Check if moving to a different list and handle todo mode
          const sourceList = draggedItem.closest('.list');
          const targetList = list;

          if (sourceList !== targetList) {
            // Handle todo mode inheritance
            const targetHasTodoMode = targetList.classList.contains('todo-mode');
            const sourceHasTodoMode = sourceList.classList.contains('todo-mode');

            // Handle date mode inheritance
            const targetHasDateMode = targetList.classList.contains('date-mode');
            const sourceHasDateMode = sourceList.classList.contains('date-mode');

            if (targetHasTodoMode && !sourceHasTodoMode) {
              // Add checkboxes to moved item and sub-items
              const mainItem = draggedItem.querySelector('.list-item');
              if (mainItem && !mainItem.querySelector('.custom-checkbox')) {
                addCheckboxToItem(mainItem);
              }

              draggedItem.querySelectorAll('.list-item-sub').forEach(subItem => {
                const input = subItem.querySelector('input[type="text"]');
                if (input && input.value.trim() !== '' && !subItem.querySelector('.custom-checkbox')) {
                  addCheckboxToItem(subItem);
                }
              });

            } else if (!targetHasTodoMode && sourceHasTodoMode) {
              // Remove checkboxes from moved item and sub-items
              draggedItem.querySelectorAll('.custom-checkbox').forEach(checkbox => {
                checkbox.remove();
              });

              // Remove completed styling
              draggedItem.querySelectorAll('input.todo-completed').forEach(input => {
                input.classList.remove('todo-completed');
              });
            }

            // Handle date mode inheritance
            if (targetHasDateMode && !sourceHasDateMode) {
              // Add date input to moved item (only main item, not sub-items)
              const mainItem = draggedItem.querySelector('.list-item');
              if (mainItem && !mainItem.querySelector('.date-container')) {
                addDateInputToItem(mainItem);
              }

            } else if (!targetHasDateMode && sourceHasDateMode) {
              // Remove date input from moved item
              const mainItem = draggedItem.querySelector('.list-item');
              if (mainItem) {
                const dateContainer = mainItem.querySelector('.date-container');
                const dateSeparator = mainItem.querySelector('.date-separator');
                const itemContent = mainItem.querySelector('.item-content');

                if (dateContainer) dateContainer.remove();
                if (dateSeparator) dateSeparator.remove();

                if (itemContent) {
                  // Move children back to the item directly
                  while (itemContent.firstChild) {
                    mainItem.appendChild(itemContent.firstChild);
                  }
                  itemContent.remove();
                }
              }
            }
          }

          if (afterElement == null) {
            itemContainer.appendChild(draggedItem);
          } else {
            itemContainer.insertBefore(draggedItem, afterElement);
          }
        }
        placeholder.remove();
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.item-wrapper:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Modal functions
    let currentEditingItem = null;

    window.openEditModal = function (item) {
      currentEditingItem = item;
      const modal = document.getElementById('edit-modal');

      // Populate the modal with current item data
      populateModalData(item);

      // Show modal with animation
      modal.style.display = 'block';
      requestAnimationFrame(() => {
        modal.classList.add('show');
      });

      // Focus the textarea for immediate editing
      document.getElementById('modal-item-text').focus();
    };

    window.closeEditModal = function () {
      const modal = document.getElementById('edit-modal');
      modal.classList.remove('show');

      // Hide after animation completes
      setTimeout(() => {
        modal.style.display = 'none';
        currentEditingItem = null;
      }, 300);
    };

    function populateModalData(item) {
      const textInput = item.querySelector('input[type="text"]');
      const list = item.closest('.list');
      const isDateMode = list.classList.contains('date-mode');
      const isTodoMode = list.classList.contains('todo-mode');

      // Populate text
      document.getElementById('modal-item-text').value = textInput ? textInput.value : '';

      // Handle date mode
      const dateSection = document.getElementById('modal-date-section');
      if (isDateMode) {
        dateSection.style.display = 'block';
        populateDateDropdowns();

        const daySelect = item.querySelector('.date-day');
        const monthSelect = item.querySelector('.date-month');

        if (daySelect && monthSelect) {

          document.getElementById('modal-day').value = daySelect.value;
          document.getElementById('modal-month').value = monthSelect.value;
        }
      } else {
        dateSection.style.display = 'none';
      }

      // Handle todo mode
      const todoSection = document.getElementById('modal-todo-section');
      if (isTodoMode) {
        todoSection.style.display = 'block';
        const checkbox = item.querySelector('.custom-checkbox input[type="checkbox"]');
        document.getElementById('modal-todo-completed').checked = checkbox ? checkbox.checked : false;
      } else {
        todoSection.style.display = 'none';
      }
    }

    function populateDateDropdowns() {
      const daySelect = document.getElementById('modal-day');
      const monthSelect = document.getElementById('modal-month');

      // Populate day dropdown
      daySelect.innerHTML = '';
      for (let i = 1; i <= 31; i++) {
        const dayStr = i.toString().padStart(2, '0');
        daySelect.innerHTML += `<option value="${i}">${dayStr}</option>`;
      }

      // Populate month dropdown
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      monthSelect.innerHTML = '';
      months.forEach((month, index) => {
        monthSelect.innerHTML += `<option value="${index + 1}">${month}</option>`;
      });
    }

    window.saveEditModal = function () {
      if (!currentEditingItem) return;

      const list = currentEditingItem.closest('.list');
      const isDateMode = list.classList.contains('date-mode');
      const isTodoMode = list.classList.contains('todo-mode');

      // Update text
      const textInput = currentEditingItem.querySelector('input[type="text"]');
      if (textInput) {
        textInput.value = document.getElementById('modal-item-text').value;
        textInput.title = textInput.value;
      }

      // Update date if in date mode
      if (isDateMode) {
        const daySelect = currentEditingItem.querySelector('.date-day');
        const monthSelect = currentEditingItem.querySelector('.date-month');

        if (daySelect && monthSelect) {
          daySelect.value = document.getElementById('modal-day').value;
          monthSelect.value = document.getElementById('modal-month').value;
        }
      }

      // Update todo status if in todo mode
      if (isTodoMode) {
        const checkbox = currentEditingItem.querySelector('.custom-checkbox input');
        const modalCheckbox = document.getElementById('modal-todo-completed');

        if (checkbox) {
          checkbox.checked = modalCheckbox.checked;

          // Update text styling based on completion
          if (textInput) {
            if (modalCheckbox.checked) {
              textInput.classList.add('todo-completed');
            } else {
              textInput.classList.remove('todo-completed');
            }
          }
        }
      }

      closeEditModal();
    };

    // Add keyboard shortcuts and click-outside-to-close for modal
    document.addEventListener('keydown', function (e) {
      const modal = document.getElementById('edit-modal');
      if (modal.classList.contains('show')) {
        if (e.key === 'Escape') {
          closeEditModal();
        } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          saveEditModal();
        }
      }
    });

    // Click outside to close modal
    document.getElementById('edit-modal').addEventListener('click', function (e) {
      if (e.target === this) {
        closeEditModal();
      }
    });

    window.deleteCurrentItem = function () {
      if (currentEditingItem && confirm('Delete this item?')) {
        if (currentEditingItem.classList.contains('list-item')) {
          currentEditingItem.parentElement.remove();
        } else {
          currentEditingItem.remove();
        }
        closeEditModal();
      }
    };

    // Toggle move dropdown menu
    function toggleMoveDropdown(moveBtn) {
      const dropdown = moveBtn.querySelector('.move-dropdown-menu');
      const isOpen = dropdown.classList.contains('open');
      const listItem = moveBtn.closest('.list-item, .list-item-sub');

      // Close all other move dropdowns first and remove open classes
      document.querySelectorAll('.move-dropdown-menu.open').forEach(menu => {
        menu.classList.remove('open');
      });
      document.querySelectorAll('.list-item.move-menu-open, .list-item-sub.move-menu-open').forEach(item => {
        item.classList.remove('move-menu-open');
      });

      // Toggle this dropdown
      if (!isOpen) {
        dropdown.classList.add('open');
        if (listItem) {
          listItem.classList.add('move-menu-open');
        }
      }
    }

    // Perform move action - centralized function
    function performMoveAction(action, moveBtn) {
      console.log('⚡ performMoveAction called:', action);

      // Find the item wrapper
      const listItem = moveBtn.closest('.list-item, .list-item-sub');
      if (!listItem) {
        console.error('Could not find list item');
        return;
      }

      const itemWrapper = listItem.parentElement;
      if (!itemWrapper || !itemWrapper.classList.contains('item-wrapper')) {
        console.error('Could not find item wrapper');
        return;
      }

      const currentList = itemWrapper.closest('.list');
      if (!currentList) {
        console.error('Could not find list');
        return;
      }

      const itemsContainer = currentList.querySelector('.items');
      if (!itemsContainer) {
        console.error('Could not find items container');
        return;
      }

      console.log('✅ All elements found, executing move:', action);

      // Perform the move
      if (action === 'top') {
        itemsContainer.insertBefore(itemWrapper, itemsContainer.firstChild);
        console.log('✅ Moved to top');
      } else if (action === 'bottom') {
        itemsContainer.appendChild(itemWrapper);
        console.log('✅ Moved to bottom');
      } else if (action === 'up') {
        const previousSibling = itemWrapper.previousElementSibling;
        if (previousSibling) {
          itemsContainer.insertBefore(itemWrapper, previousSibling);
          console.log('✅ Moved up one');
        } else {
          console.log('⚠️ Already at top, cannot move up');
        }
      } else if (action === 'down') {
        const nextSibling = itemWrapper.nextElementSibling;
        if (nextSibling) {
          itemsContainer.insertBefore(nextSibling, itemWrapper);
          console.log('✅ Moved down one');
        } else {
          console.log('⚠️ Already at bottom, cannot move down');
        }
      }

      // Close the dropdown
      const dropdown = moveBtn.querySelector('.move-dropdown-menu');
      if (dropdown) {
        dropdown.classList.remove('open');
      }
      if (listItem) {
        listItem.classList.remove('move-menu-open');
      }

      // Save changes
      autoSave();
    }

    // Handle move dropdown clicks - simplified approach
    document.addEventListener('click', function (e) {
      // Skip click handling during drag operations to prevent interference
      if (isDragInProgress) {
        console.log('Skipping click handling during drag operation');
        return;
      }

      console.log('Click detected on element:', e.target.tagName, e.target.className);
      console.log('Text content:', e.target.textContent?.substring(0, 30));

      // Find the closest move dropdown item by traversing up the DOM
      let moveDropdownItem = e.target.closest('.move-dropdown-item');

      if (moveDropdownItem) {
        e.stopPropagation();
        e.preventDefault();

        console.log('✅ Move dropdown item found!');
        console.log('Action:', moveDropdownItem.getAttribute('data-action'));

        const action = moveDropdownItem.getAttribute('data-action');
        const moveBtn = moveDropdownItem.closest('.move-item-btn');

        console.log('Move dropdown clicked:', action);
        console.log('Move button found:', !!moveBtn);

        if (!moveBtn) {
          console.error('Could not find move button');
          return;
        }

        // Find the item wrapper - it should be the parent of the list-item that contains the moveBtn
        const listItem = moveBtn.closest('.list-item, .list-item-sub');
        console.log('List item found:', !!listItem);

        if (!listItem) {
          console.error('Could not find list item');
          return;
        }

        const itemWrapper = listItem.parentElement;
        console.log('Item wrapper found:', !!itemWrapper);
        console.log('Item wrapper class:', itemWrapper ? itemWrapper.className : 'none');

        if (!itemWrapper || !itemWrapper.classList.contains('item-wrapper')) {
          console.error('Could not find item wrapper');
          return;
        }

        const currentList = itemWrapper.closest('.list');
        if (!currentList) {
          console.error('Could not find list');
          return;
        }

        const itemsContainer = currentList.querySelector('.items');
        if (!itemsContainer) {
          console.error('Could not find items container');
          return;
        }

        console.log('All elements found, executing move:', action);

        if (action === 'top') {
          // Move to top of list
          itemsContainer.insertBefore(itemWrapper, itemsContainer.firstChild);
          console.log('Moved to top');
          autoSave();
        } else if (action === 'bottom') {
          // Move to bottom of list
          itemsContainer.appendChild(itemWrapper);
          console.log('Moved to bottom');
          autoSave();
        } else if (action === 'up') {
          // Move up one position
          const previousSibling = itemWrapper.previousElementSibling;
          if (previousSibling) {
            itemsContainer.insertBefore(itemWrapper, previousSibling);
            console.log('Moved up one');
            autoSave();
          } else {
            console.log('Already at top, cannot move up');
          }
        } else if (action === 'down') {
          // Move down one position
          const nextSibling = itemWrapper.nextElementSibling;
          if (nextSibling) {
            itemsContainer.insertBefore(nextSibling, itemWrapper);
            console.log('Moved down one');
            autoSave();
          } else {
            console.log('Already at bottom, cannot move down');
          }
        }

        // Close the dropdown and remove open class from list item
        const dropdown = e.target.closest('.move-dropdown-menu');

        if (dropdown) {
          dropdown.classList.remove('open');
        }
        if (listItem) {
          listItem.classList.remove('move-menu-open');
        }
      }
    });

    // Close move dropdowns when clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.move-item-btn') && !e.target.closest('.move-dropdown-menu')) {
        document.querySelectorAll('.move-dropdown-menu.open').forEach(menu => {
          menu.classList.remove('open');
        });
        document.querySelectorAll('.list-item.move-menu-open, .list-item-sub.move-menu-open').forEach(item => {
          item.classList.remove('move-menu-open');
        });
      }
    });



    // Dropdown menu logic
    const menuButton = document.getElementById('menu-button-top');
    const dropdownMenu = document.getElementById('dropdown-menu');
    const stylesMenuItem = document.getElementById('styles-menu-item');
    const stylesSubmenu = document.getElementById('styles-submenu');

    menuButton.addEventListener('click', function (e) {
      e.stopPropagation();
      const isOpen = dropdownMenu.style.display === 'block';
      dropdownMenu.style.display = isOpen ? 'none' : 'block';
    });

    document.addEventListener('click', function (e) {
      if (!e.target.closest('#dropdown-menu') && !e.target.closest('#menu-button-top')) {
        dropdownMenu.style.display = 'none';
        if (stylesSubmenu) stylesSubmenu.style.display = 'none';
      }
    });

    if (stylesMenuItem && stylesSubmenu) {
      stylesMenuItem.addEventListener('click', function (e) {
        e.stopPropagation();
        const isOpen = stylesSubmenu.style.display === 'block';
        if (isOpen) {
          stylesSubmenu.style.display = 'none';
          return;
        }
        const stylesRect = stylesMenuItem.getBoundingClientRect();
        const dropdownRect = dropdownMenu.getBoundingClientRect();
        stylesSubmenu.style.top = stylesRect.top + 'px';
        stylesSubmenu.style.left = (dropdownRect.left - 140) + 'px';
        stylesSubmenu.style.display = 'block';
      });

      stylesSubmenu.querySelectorAll('.submenu-item').forEach(function (item) {
        item.addEventListener('click', function () {
          stylesSubmenu.style.display = 'none';
          dropdownMenu.style.display = 'none';
        });
      });
    }

    // List dropdown functionality with proper z-index management
    container.addEventListener('click', function (e) {
      if (e.target.closest('.list-menu-btn')) {
        e.stopPropagation();
        const btn = e.target.closest('.list-menu-btn');
        const dropdown = btn.parentElement.querySelector('.list-dropdown-menu');
        const parentList = btn.closest('.list');

        // Check if this menu is already open
        const isAlreadyOpen = dropdown.classList.contains('open');

        // Close all other menus first and reset z-indexes
        document.querySelectorAll('.list-dropdown-menu').forEach(m => {
          m.classList.remove('open');
        });
        document.querySelectorAll('.list').forEach(list => {
          list.style.zIndex = '';
          list.style.position = '';
          // Reset sub-items z-index only for lists that had menus open
          list.querySelectorAll('.list-item-sub').forEach(subItem => {
            subItem.style.zIndex = '';
          });
        });

        // If it wasn't already open, open it
        if (!isAlreadyOpen) {
          dropdown.classList.add('open');
          // Bring parent list to front with very high z-index
          parentList.style.zIndex = '99999';
          parentList.style.position = 'relative';

          // Set sub-items to low z-index ONLY in the current list where menu is open
          parentList.querySelectorAll('.list-item-sub').forEach(subItem => {
            subItem.style.zIndex = '-1';
          });
        }
        return;
      }

      if (e.target.classList.contains('list-dropdown-item')) {
        const list = e.target.closest('.list');
        const dropdown = e.target.closest('.list-dropdown-menu');
        const action = e.target.textContent.trim();

        if (action === 'Cycle size') {
          const container = document.getElementById('list-container');
          if (container.classList.contains('masonry')) {
            // Disable cycle size in masonry mode
            alert('Cycle size is disabled in masonry mode. Switch back to grid layout to use this feature.');
            return;
          }

          const sizes = ['size-1', 'size-2', 'size-3', 'size-4'];
          let currentIdx = sizes.findIndex(size => list.classList.contains(size));
          if (currentIdx === -1) currentIdx = 0;
          let nextIdx = (currentIdx + 1) % sizes.length;
          sizes.forEach(size => list.classList.remove(size));
          list.classList.add(sizes[nextIdx]);
          autoSave(); // Save size change

        } else if (action === 'Change color') {
          const colors = ["#f7d6d0", "#ffb6cb", "#e5e1ea", "#b3d8fa", "#b7e5dd", "#fcf3ab"];
          const newColor = colors[Math.floor(Math.random() * colors.length)];
          list.setAttribute('data-original-bg', newColor);
          if (currentStyle === 1) {
            list.style.backgroundColor = newColor;
          } else if (currentStyle === 2) {
            const accent = list.querySelector('.list-accent');
            if (accent) accent.style.background = newColor;
          }
          autoSave(); // Save color change

        } else if (action === 'Todo-mode') {
          toggleTodoMode(list);
          autoSave(); // Save todo mode change

        } else if (action === 'Date-mode') {
          toggleDateMode(list);
          autoSave(); // Save date mode change

        } else if (action === 'Export list') {
          exportList(list);

        } else if (action === 'Delete list') {
          if (confirm('Delete this list?')) {
            list.remove();
            updateListPositions(); // Update positions after deletion
            refreshLayout(); // Refresh masonry layout if enabled
            autoSave(); // Save after deletion
          }
        }

        // Close menu and reset z-indexes
        dropdown.classList.remove('open');
        document.querySelectorAll('.list').forEach(list => {
          list.style.zIndex = '';
          list.style.position = '';
          // Reset sub-items z-index for all lists
          list.querySelectorAll('.list-item-sub').forEach(subItem => {
            subItem.style.zIndex = '';
          });
        });
      }
    });

    // Close menus when clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.list-dropdown-menu') && !e.target.closest('.list-menu-btn')) {
        document.querySelectorAll('.list-dropdown-menu').forEach(m => {
          m.classList.remove('open');
        });
        document.querySelectorAll('.list').forEach(list => {
          list.style.zIndex = '';
          list.style.position = '';
          // Reset sub-items z-index for all lists
          list.querySelectorAll('.list-item-sub').forEach(subItem => {
            subItem.style.zIndex = '';
          });
        });
      }
    });

    // Todo mode functionality
    function toggleTodoMode(list) {
      const isEnabled = list.classList.contains('todo-mode');

      if (!isEnabled) {
        // Enable todo mode
        list.classList.add('todo-mode');

        // Add checkboxes to all items
        list.querySelectorAll('.list-item').forEach(item => {
          if (!item.querySelector('.custom-checkbox')) {
            addCheckboxToItem(item);
          }
        });

        // Add checkboxes to all non-empty sub-items
        list.querySelectorAll('.list-item-sub').forEach(subItem => {
          const input = subItem.querySelector('input');
          if (input && input.value.trim() !== '' && !subItem.querySelector('.custom-checkbox')) {
            addCheckboxToItem(subItem);
          }
        });
      } else {
        // Disable todo mode
        list.classList.remove('todo-mode');

        // Remove all checkboxes
        list.querySelectorAll('.custom-checkbox').forEach(checkbox => {
          checkbox.remove();
        });

        // Remove completed styling
        list.querySelectorAll('input.todo-completed').forEach(input => {
          input.classList.remove('todo-completed');
        });
      }
    }

    // Date mode functionality
    function toggleDateMode(list) {
      const isEnabled = list.classList.contains('date-mode');

      if (!isEnabled) {
        // Enable date mode
        list.classList.add('date-mode');

        // Add date input to all main items (not sub-items)
        list.querySelectorAll('.list-item').forEach(item => {
          if (!item.querySelector('.date-container')) {
            addDateInputToItem(item);
          }
        });
      } else {
        // Disable date mode
        list.classList.remove('date-mode');

        // Remove all date inputs and restore original structure
        list.querySelectorAll('.list-item').forEach(item => {
          const dateContainer = item.querySelector('.date-container');
          const dateSeparator = item.querySelector('.date-separator');
          const itemContent = item.querySelector('.item-content');

          if (dateContainer) dateContainer.remove();
          if (dateSeparator) dateSeparator.remove();

          if (itemContent) {
            // Move children back to the item directly
            while (itemContent.firstChild) {
              item.appendChild(itemContent.firstChild);
            }
            itemContent.remove();
          }
        });
      }
    }

    function addDateInputToItem(item) {
      // Create date container
      const dateContainer = document.createElement('div');
      dateContainer.className = 'date-container';

      // Create day dropdown
      const daySelect = document.createElement('select');
      daySelect.className = 'date-day';
      const today = new Date();
      const currentDay = today.getDate();
      const currentMonth = today.getMonth() + 1; // getMonth() returns 0-11

      for (let i = 1; i <= 31; i++) {
        const dayStr = i.toString().padStart(2, '0');
        const selected = i === currentDay ? ' selected' : '';
        daySelect.innerHTML += `<option value="${i}"${selected}>${dayStr}</option>`;
      }

      // Create month dropdown
      const monthSelect = document.createElement('select');
      monthSelect.className = 'date-month';
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      months.forEach((month, index) => {
        const selected = (index + 1) === currentMonth ? ' selected' : '';
        monthSelect.innerHTML += `<option value="${index + 1}"${selected}>${month}</option>`;
      });

      // Add dropdowns to container
      dateContainer.appendChild(daySelect);
      dateContainer.appendChild(monthSelect);

      // Add event listeners to save when dates change
      daySelect.addEventListener('change', () => autoSave());
      monthSelect.addEventListener('change', () => autoSave());

      // Create separator
      const separator = document.createElement('div');
      separator.className = 'date-separator';

      // Create content wrapper for existing item content
      const itemContent = document.createElement('div');
      itemContent.className = 'item-content';

      // Move existing content to the wrapper
      const existingChildren = Array.from(item.children);
      existingChildren.forEach(child => {
        itemContent.appendChild(child);
      });

      // Add date container, separator, and content wrapper to item
      item.appendChild(dateContainer);
      item.appendChild(separator);
      item.appendChild(itemContent);
    }

    function addCheckboxToItem(item) {
      const wrapper = document.createElement('label');
      wrapper.className = 'custom-checkbox';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'todo-checkbox';

      const box = document.createElement('span');
      box.className = 'custom-checkbox-box';

      wrapper.appendChild(checkbox);
      wrapper.appendChild(box);

      // Add event listener for completion toggle
      checkbox.addEventListener('change', function () {
        const textInput = item.querySelector('input[type="text"]');
        if (textInput) {
          if (checkbox.checked) {
            textInput.classList.add('todo-completed');
          } else {
            textInput.classList.remove('todo-completed');
          }
        }
        autoSave(); // Save when checkbox state changes
      });

      // Check if item has date-mode structure
      const itemContent = item.querySelector('.item-content');
      if (itemContent) {
        // Item has date-mode structure, insert checkbox at the beginning of item-content
        // This will create the order: [day][month] | [checkbox][content]
        itemContent.insertBefore(wrapper, itemContent.firstChild);
      } else {
        // Item doesn't have date-mode structure, insert at the beginning of the item
        // This creates: [checkbox][content]
        item.insertBefore(wrapper, item.firstChild);
      }
    }

    // Export list functionality
    function exportList(list) {
      const title = list.querySelector('.title-input').value || 'Untitled List';
      const isTodoMode = list.classList.contains('todo-mode');
      const isDateMode = list.classList.contains('date-mode');
      let exportText = `${title}\n${'='.repeat(title.length)}\n\n`;

      // Get all main items
      list.querySelectorAll('.list-item').forEach(item => {
        const textInput = item.querySelector('input[type="text"]');
        const itemText = textInput ? textInput.value.trim() : '';

        if (itemText) {
          let prefix = '• ';
          let datePrefix = '';

          // Add date if in date mode
          if (isDateMode) {
            const daySelect = item.querySelector('.date-day');
            const monthSelect = item.querySelector('.date-month');
            const day = daySelect ? daySelect.value : '';
            const monthIndex = monthSelect ? monthSelect.value : '';

            if (day && monthIndex) {
              const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
              const monthName = months[parseInt(monthIndex) - 1];
              const dayFormatted = day.toString().padStart(2, '0');
              datePrefix = `[${dayFormatted} ${monthName}] `;
            }
          }

          if (isTodoMode) {
            const checkbox = item.querySelector('.custom-checkbox input');
            prefix = checkbox ? (checkbox.checked ? '[x] ' : '[ ] ') : '[ ] ';
          }

          exportText += `${datePrefix}${prefix}${itemText}\n`;

          // Get sub-items
          const wrapper = item.parentElement;
          const subItems = wrapper.querySelectorAll('.sub-items .list-item-sub');
          subItems.forEach(subItem => {
            const subTextInput = subItem.querySelector('input[type="text"]');
            const subText = subTextInput ? subTextInput.value.trim() : '';

            if (subText) {
              let subPrefix = '  ◦ ';
              if (isTodoMode) {
                const subCheckbox = subItem.querySelector('.custom-checkbox input[type="checkbox"]');
                subPrefix = subCheckbox ? (subCheckbox.checked ? '  [x] ' : '  [ ] ') : '  [ ] ';
              }
              exportText += `${subPrefix}${subText}\n`;
            }
          });
        }
      });

      // Create and download file
      const blob = new Blob([exportText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Function to update vertical line visibility for sub-items
    function updateSubItemLines(subContainer) {
      const subItems = subContainer.querySelectorAll('.list-item-sub');
      subItems.forEach((subItem, index) => {
        const input = subItem.querySelector('input[type="text"]');
        const isLast = index === subItems.length - 1;
        const isEmpty = input && input.value.trim() === '';

        // Hide line only for empty last sub-item
        if (isLast && isEmpty) {
          subItem.classList.add('hide-line');
        } else {
          subItem.classList.remove('hide-line');
        }
      });
    }

    // Modified addSubItem to create empty sub-item
    function addSubItem(element) {
      let wrapper = element.parentElement;
      let subContainer = wrapper.querySelector(".sub-items");

      // Check if there's already an empty sub-item
      const existingEmptySubItem = Array.from(subContainer.querySelectorAll('.list-item-sub')).find(subItem => {
        const input = subItem.querySelector('input[type="text"]');
        return input && input.value.trim() === '';
      });

      if (existingEmptySubItem) {
        // Focus the existing empty sub-item instead of creating a new one
        existingEmptySubItem.querySelector('input').focus();
        return;
      }

      // Create new sub-item only if no empty one exists
      const newSub = createItemSub("");
      subContainer.appendChild(newSub); // Always append to the end

      // Auto-enable todo mode checkbox if parent list has todo mode
      const list = element.closest('.list');
      if (list && list.classList.contains('todo-mode')) {
        // Don't add checkbox to empty sub-item initially
        // It will be added when user types something
      }

      // Focus first, then update lines to avoid focus interference
      newSub.querySelector('input').focus();

      // Update expand button visibility
      if (wrapper.updateExpandButton) {
        wrapper.updateExpandButton();
      }

      // Update vertical lines after focusing (use setTimeout to avoid interference)
      setTimeout(() => {
        updateSubItemLines(subContainer);
        refreshLayout(); // Refresh masonry layout when sub-item is added
      }, 0);
    }

    // Enhanced sub-item creation to handle todo mode
    function createItemSub(text = "") {
      const item = document.createElement("div");
      item.className = "list-item-sub";

      const input = document.createElement('input');
      input.type = 'text';
      input.value = text;
      input.className = 'item-input';
      input.placeholder = 'Add sub-item and press Enter';
      input.addEventListener('input', () => {
        input.title = input.value;

        // Add checkbox if in todo mode and input has content
        const list = item.closest('.list');
        if (list && list.classList.contains('todo-mode') && input.value.trim() !== '' && !item.querySelector('.custom-checkbox')) {
          addCheckboxToItem(item);
        }

        // Update vertical lines
        const subContainer = item.parentElement;
        if (subContainer && subContainer.classList.contains('sub-items')) {
          updateSubItemLines(subContainer);
        }
      });
      item.appendChild(input);

      // Add Enter key and blur functionality for creating new sub-items
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const text = input.value.trim();
          if (text !== "") {
            const subContainer = item.parentElement;
            const newSub = createItemSub("");
            subContainer.appendChild(newSub); // Always append to end

            // Update lines and focus
            updateSubItemLines(subContainer);
            newSub.querySelector('input').focus();
          }
        }
      });

      input.addEventListener("blur", () => {
        const text = input.value.trim();
        if (text === "") {
          // If empty, remove this sub-item entirely
          const subContainer = item.parentElement;
          const wrapper = subContainer.parentElement;
          item.remove();

          // Update expand button visibility after deletion
          if (wrapper && wrapper.updateExpandButton) {
            wrapper.updateExpandButton();
          }

          // Update lines after removal
          if (subContainer && subContainer.classList.contains('sub-items')) {
            updateSubItemLines(subContainer);
          }
          autoSave();
          return;
        }

        // If not empty, continue with normal behavior
        // Check if this is the last sub-item and if it's not empty
        const subContainer = item.parentElement;
        const subItems = subContainer.querySelectorAll('.list-item-sub');
        const isLast = item === subItems[subItems.length - 1];

        if (isLast) {
          const newSub = createItemSub("");
          subContainer.appendChild(newSub);
          // Auto-focus the new sub-item
          setTimeout(() => {
            newSub.querySelector('input').focus();
          }, 0);
        }

        // Update vertical lines
        if (subContainer && subContainer.classList.contains('sub-items')) {
          updateSubItemLines(subContainer);
        }

        autoSave(); // Save when user finishes editing a sub-item
      });

      const editBtn = document.createElement('button');
      editBtn.className = 'edit-item-btn';
      editBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>edit</span>";
      editBtn.onclick = function () { openEditModal(item); };
      item.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-item-btn";
      deleteBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>close</span>";
      deleteBtn.onclick = function () {
        const subContainer = item.parentElement;
        const wrapper = subContainer.parentElement;
        item.remove();

        // Update expand button visibility after deletion
        if (wrapper && wrapper.updateExpandButton) {
          wrapper.updateExpandButton();
        }

        autoSave(); // Save when sub-item is deleted
      };
      item.appendChild(deleteBtn);

      return item;
    }

    // Main dropdown menu click handler
    dropdownMenu.addEventListener('click', function (e) {
      if (e.target.classList.contains('dropdown-item')) {
        const action = e.target.textContent.trim();

        if (action === 'Clear Empty Lists') {
          clearEmptyLists();
        } else if (action === 'Masonry Layout' || action === '✓ Masonry Layout') {
          toggleMasonryLayout();
          // Update button text
          const masonryToggle = document.getElementById('masonry-toggle');
          const container = document.getElementById('list-container');
          if (container.classList.contains('masonry')) {
            masonryToggle.textContent = '✓ Masonry Layout';
          } else {
            masonryToggle.textContent = 'Masonry Layout';
          }
        }

        // Close the dropdown menu after clicking any item
        dropdownMenu.style.display = 'none';
      }
    });

    // Function to clear empty lists
    function clearEmptyLists() {
      const allLists = document.querySelectorAll('.list');
      let emptyLists = [];

      // Find all empty lists
      allLists.forEach(list => {
        const titleInput = list.querySelector('.title-input');
        const listItems = list.querySelectorAll('.list-item input');
        const subItems = list.querySelectorAll('.list-item-sub input');

        // Check if title is empty or just whitespace
        const hasTitle = titleInput && titleInput.value.trim() !== '';

        // Check if there are any non-empty list items
        let hasItems = false;
        listItems.forEach(input => {
          if (input.value.trim() !== '') {
            hasItems = true;
          }
        });

        // Check if there are any non-empty sub-items
        let hasSubItems = false;
        subItems.forEach(input => {
          if (input.value.trim() !== '') {
            hasSubItems = true;
          }
        });

        // If no title, no items, and no sub-items, it's empty
        if (!hasTitle && !hasItems && !hasSubItems) {
          emptyLists.push(list);
        }
      });

      if (emptyLists.length === 0) {
        alert('No empty lists found.');
        return;
      }

      // Show confirmation dialog
      const confirmMessage = `Found ${emptyLists.length} empty list${emptyLists.length > 1 ? 's' : ''}. Are you sure you want to delete ${emptyLists.length > 1 ? 'them' : 'it'}?`;

      if (confirm(confirmMessage)) {
        emptyLists.forEach(list => {
          list.remove();
        });
        refreshLayout(); // Refresh masonry layout if enabled
        autoSave(); // Save after clearing empty lists
      }
    }

    // LocalStorage functionality
    function saveToLocalStorage() {
      try {
        const data = {
          lists: getAllListsData(),
          appSettings: {
            currentStyle: currentStyle,
            isDarkMode: document.body.classList.contains('dark')
          }
        };
        localStorage.setItem('smartLists', JSON.stringify(data));
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    function getAllListsData() {
      const lists = document.querySelectorAll('.list');
      return Array.from(lists).map(list => {
        const titleInput = list.querySelector('.title-input');
        const listItems = list.querySelectorAll('.list-item');
        const isInTodoMode = list.classList.contains('todo-mode');
        const isInDateMode = list.classList.contains('date-mode');

        // Get list size
        let size = 'size-1';
        ['size-1', 'size-2', 'size-3', 'size-4'].forEach(s => {
          if (list.classList.contains(s)) size = s;
        });

        // Get background color
        const bgColor = list.getAttribute('data-original-bg') || '#f7d6d0';

        // Get all list items data
        const items = Array.from(listItems).map((item, index) => {
          const input = item.querySelector('input[type="text"]');
          const checkbox = item.querySelector('.custom-checkbox input');

          // Get sub-items from the sub-container
          let subItems = [];
          const subContainer = item.closest('.item-wrapper')?.querySelector('.sub-items');
          if (subContainer) {
            const subInputs = subContainer.querySelectorAll('.list-item-sub input[type="text"]');
            subItems = Array.from(subInputs).map(subInput => {
              const subCheckbox = subInput.closest('.list-item-sub').querySelector('.custom-checkbox input');
              return {
                text: subInput.value || '',
                checked: subCheckbox ? subCheckbox.checked : false
              };
            }).filter(sub => sub.text.trim() !== ''); // Only save non-empty sub-items
          }

          // Get date information if in date mode
          let dateInfo = null;
          if (isInDateMode) {
            const daySelect = item.querySelector('.date-day');
            const monthSelect = item.querySelector('.date-month');

            if (daySelect && monthSelect) {
              const dayValue = daySelect.value;
              const monthValue = monthSelect.value;

              // Accept any non-empty values
              if (dayValue !== '' && monthValue !== '') {
                dateInfo = {
                  day: dayValue,
                  month: monthValue
                };
              }
            }
          }

          // Check if sub-items are collapsed
          const isCollapsed = subContainer && subContainer.style.display === 'none';

          const itemData = {
            text: input ? input.value || '' : '',
            checked: checkbox ? checkbox.checked : false,
            subItems: subItems,
            dateInfo: dateInfo,
            collapsed: isCollapsed
          };

          return itemData;
        }).filter(item => item.text.trim() !== '' || item.subItems.length > 0); // Keep items with content or sub-items

        return {
          title: titleInput ? titleInput.value || '' : '',
          items: items,
          settings: {
            todoMode: isInTodoMode,
            dateMode: isInDateMode,
            size: size,
            backgroundColor: bgColor
          }
        };
      });
    }

    function loadFromLocalStorage() {
      try {
        const saved = localStorage.getItem('smartLists');
        if (saved) {
          const data = JSON.parse(saved);

          // Clear existing lists
          const container = document.getElementById('list-container');
          container.innerHTML = '';

          // Restore app settings
          if (data.appSettings) {
            if (data.appSettings.currentStyle) {
              currentStyle = data.appSettings.currentStyle;
              applyCurrentStyleToAllLists();
            }
            if (data.appSettings.isDarkMode) {
              document.body.classList.add('dark');
              document.getElementById('toggle-dark').checked = true;
            }
          }

          // Recreate lists
          if (data.lists && data.lists.length > 0) {
            data.lists.forEach(listData => {
              recreateListFromData(listData);
            });
            // Update position indicators after loading all lists
            updateListPositions();
          } else {
            // If no saved lists, create default empty list
            createList();
          }

          return true; // Successfully loaded
        }
      } catch (error) {
        console.error('Error loading from localStorage:', error);
      }
      return false; // No data or error
    }

    function recreateListFromData(listData) {
      // Create a completely fresh list
      const list = createList();

      // Set title
      const titleInput = list.querySelector('.title-input');
      if (titleInput && listData.title) {
        titleInput.value = listData.title;
      }

      // Apply basic settings
      if (listData.settings) {
        // Set background color
        if (listData.settings.backgroundColor) {
          list.setAttribute('data-original-bg', listData.settings.backgroundColor);
          if (currentStyle === 1) {
            list.style.backgroundColor = listData.settings.backgroundColor;
          } else if (currentStyle === 2) {
            const accent = list.querySelector('.list-accent');
            if (accent) accent.style.background = listData.settings.backgroundColor;
          }
        }

        // Set size
        if (listData.settings.size) {
          ['size-1', 'size-2', 'size-3', 'size-4'].forEach(s => list.classList.remove(s));
          list.classList.add(listData.settings.size);
        }
      }

      // If no items to restore, keep the default empty item and return
      if (!listData.items || listData.items.length === 0) {
        return list;
      }

      // Clear the default item created by createList()
      const itemsContainer = list.querySelector('.items');
      if (itemsContainer) {
        itemsContainer.innerHTML = '';
      }

      // Create items manually to match exact original structure
      listData.items.forEach((itemData, index) => {
        if (itemData.text.trim() !== '' || (itemData.subItems && itemData.subItems.length > 0)) {
          // Manually create wrapper and item to match original structure
          const wrapper = document.createElement('div');
          wrapper.className = 'item-wrapper';

          const item = document.createElement("div");
          item.className = "list-item";
          item.setAttribute("draggable", true);

          const input = document.createElement('input');
          input.type = 'text';
          input.value = itemData.text;
          input.className = 'item-input';
          input.title = itemData.text;

          // Add essential event listeners
          input.addEventListener('input', () => {
            input.title = input.value;
            autoSave();
          });
          input.addEventListener('blur', () => autoSave());

          item.appendChild(input);

          // Add buttons in consistent order: expand/collapse, plus, move, edit, delete
          const expandBtn = document.createElement('button');
          expandBtn.className = 'expand-collapse-btn';
          expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
          expandBtn.style.display = 'none'; // Initially hidden
          expandBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            const subContainer = wrapper.querySelector('.sub-items');
            if (subContainer.style.display === "none") {
              subContainer.style.display = "";
              expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_down</span>";
            } else {
              subContainer.style.display = "none";
              expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
            }
            autoSave(); // Save the collapsed/expanded state
          });
          item.appendChild(expandBtn);

          const plusBtn = document.createElement('button');
          plusBtn.className = 'list-item-sub-btn';
          plusBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>add</span>";
          plusBtn.addEventListener('click', function () {
            addSubItem(item); // Use the centralized addSubItem function
          });
          item.appendChild(plusBtn);

          const moveBtn = document.createElement('button');
          moveBtn.className = 'move-item-btn';
          moveBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>open_with</span>";
          moveBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            toggleMoveDropdown(moveBtn);
          });

          // Create move dropdown menu with proper event delegation
          const moveDropdown = document.createElement('div');
          moveDropdown.className = 'move-dropdown-menu';

          // Create dropdown items with direct click handlers for recreated lists
          const topItemRec = document.createElement('div');
          topItemRec.className = 'move-dropdown-item';
          topItemRec.textContent = 'Move to top of list';
          topItemRec.onclick = function (e) {
            e.stopPropagation();
            console.log('🔥 TOP CLICKED DIRECTLY (recreated)');
            performMoveAction('top', moveBtn);
          };

          const upItemRec = document.createElement('div');
          upItemRec.className = 'move-dropdown-item';
          upItemRec.textContent = 'Move up one row';
          upItemRec.onclick = function (e) {
            e.stopPropagation();
            console.log('🔥 UP CLICKED DIRECTLY (recreated)');
            performMoveAction('up', moveBtn);
          };

          const downItemRec = document.createElement('div');
          downItemRec.className = 'move-dropdown-item';
          downItemRec.textContent = 'Move down one row';
          downItemRec.onclick = function (e) {
            e.stopPropagation();
            console.log('🔥 DOWN CLICKED DIRECTLY (recreated)');
            performMoveAction('down', moveBtn);
          };

          const bottomItemRec = document.createElement('div');
          bottomItemRec.className = 'move-dropdown-item';
          bottomItemRec.textContent = 'Move to bottom of list';
          bottomItemRec.onclick = function (e) {
            e.stopPropagation();
            console.log('🔥 BOTTOM CLICKED DIRECTLY (recreated)');
            performMoveAction('bottom', moveBtn);
          };

          moveDropdown.appendChild(topItemRec);
          moveDropdown.appendChild(upItemRec);
          moveDropdown.appendChild(downItemRec);
          moveDropdown.appendChild(bottomItemRec);

          moveBtn.appendChild(moveDropdown);
          item.appendChild(moveBtn);

          const editBtn = document.createElement('button');
          editBtn.className = 'edit-item-btn';
          editBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>edit</span>";
          editBtn.addEventListener('click', function () {
            window.openEditModal(item);
          });
          item.appendChild(editBtn);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-item-btn';
          deleteBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>close</span>";
          deleteBtn.addEventListener('click', function () {
            wrapper.remove();
            autoSave();
          });
          item.appendChild(deleteBtn);

          wrapper.appendChild(item);

          // Add drag functionality
          item.addEventListener("dragstart", (e) => {
            draggedItem = wrapper;
            wrapper.classList.add("dragging");
            isDragInProgress = true; // Disable auto-save during modal item drag
          });
          item.addEventListener("dragend", () => {
            wrapper.classList.remove("dragging");
            isDragInProgress = false; // Re-enable auto-save after modal item drag
            autoSave(); // Save the final position
          });

          // Add sub-items if they exist
          if (itemData.subItems && itemData.subItems.length > 0) {
            const subContainer = document.createElement("div");
            subContainer.className = "sub-items";
            subContainer.style.display = '';

            // Create each sub-item using createItemSub
            itemData.subItems.forEach(subData => {
              if (subData.text.trim() !== '') {
                const subItem = createItemSub(subData.text);
                subContainer.appendChild(subItem);
              }
            });

            // Don't add empty sub-item when loading from saved data

            // Update vertical lines after loading sub-items
            setTimeout(() => {
              updateSubItemLines(subContainer);
            }, 0);

            // Restore collapsed state if it was saved
            if (itemData.collapsed) {
              subContainer.style.display = 'none';
            }

            wrapper.appendChild(subContainer);
          } else {
            // Even if no sub-items exist, create the sub-container for future use
            const subContainer = document.createElement("div");
            subContainer.className = "sub-items";
            subContainer.style.display = '';
            wrapper.appendChild(subContainer);
          }

          // Add updateExpandButton function to wrapper
          wrapper.updateExpandButton = function () {
            const subContainer = wrapper.querySelector('.sub-items');
            if (subContainer.children.length > 0) {
              expandBtn.style.display = 'inline';
              wrapper.classList.add('has-sub-items');
              // Check if sub-items are currently collapsed
              if (subContainer.style.display === 'none') {
                expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_right</span>";
              } else {
                expandBtn.innerHTML = "<span class='material-icons' style='font-size:18px;'>keyboard_arrow_down</span>";
                subContainer.style.display = '';
              }
            } else {
              expandBtn.style.display = 'none';
              wrapper.classList.remove('has-sub-items');
              subContainer.style.display = '';
            }
          };

          // Update expand button visibility
          wrapper.updateExpandButton();

          itemsContainer.appendChild(wrapper);
        }
      });

      // The input field structure is already created by createList(), no need to add another one

      // Apply modes AFTER all items are created
      if (listData.settings) {
        if (listData.settings.todoMode) {
          // Don't use toggleTodoMode as it will add checkboxes automatically
          // Instead, manually add the class and handle checkboxes ourselves
          list.classList.add('todo-mode');

          // Restore checkbox states immediately after DOM is ready
          const itemWrappers = list.querySelectorAll('.item-wrapper');
          listData.items.forEach((itemData, index) => {
            if (index < itemWrappers.length) {
              const wrapper = itemWrappers[index];
              const item = wrapper.querySelector('.list-item');

              // Add checkbox to main item and restore state
              if (item && !item.querySelector('.custom-checkbox')) {
                addCheckboxToItem(item);
                if (itemData.checked) {
                  const checkbox = item.querySelector('.custom-checkbox input');
                  const textInput = item.querySelector('input[type="text"]');
                  if (checkbox && textInput) {
                    checkbox.checked = true;
                    if (itemData.checked) {
                      textInput.classList.add('todo-completed');
                    }
                  }
                }
              }

              // Handle sub-items
              if (itemData.subItems && itemData.subItems.length > 0) {
                const subContainer = wrapper.querySelector('.sub-items');
                if (subContainer) {
                  const subItems = subContainer.querySelectorAll('.list-item-sub');

                  itemData.subItems.forEach((subData, subIndex) => {
                    if (subIndex < subItems.length) {
                      const subItem = subItems[subIndex];
                      const subInput = subItem.querySelector('input[type="text"]');

                      // Add checkbox to sub-items that have text
                      if (subInput && subInput.value.trim() !== '' && !subItem.querySelector('.custom-checkbox')) {
                        addCheckboxToItem(subItem);

                        // Restore checkbox state and styling
                        if (subData.checked) {
                          const subCheckbox = subItem.querySelector('.custom-checkbox input');
                          if (subCheckbox) {
                            subCheckbox.checked = true;
                            subInput.classList.add('todo-completed');
                          }
                        }
                      }
                    }
                  });
                }
              }
            }
          });
        }

        if (listData.settings.dateMode) {
          toggleDateMode(list);
          // Restore date values
          setTimeout(() => {
            const itemWrappers = list.querySelectorAll('.item-wrapper');
            listData.items.forEach((itemData, index) => {
              if (index < itemWrappers.length && itemData.dateInfo) { // Remove -1, process all items
                const wrapper = itemWrappers[index];
                const item = wrapper.querySelector('.list-item');
                const daySelect = item.querySelector('.date-day');
                const monthSelect = item.querySelector('.date-month');
                if (daySelect && monthSelect && itemData.dateInfo.day && itemData.dateInfo.month) {
                  // Set month first
                  monthSelect.value = itemData.dateInfo.month;

                  // Validate day for the selected month
                  let day = parseInt(itemData.dateInfo.day);
                  const month = parseInt(itemData.dateInfo.month);
                  const daysInMonth = new Date(2024, month, 0).getDate(); // Get days in month

                  if (day > daysInMonth) {
                    day = daysInMonth; // Adjust to last day of month
                    console.log(`Adjusted day ${itemData.dateInfo.day} to ${day} for month ${month}`);
                  }

                  daySelect.value = day.toString();

                  // Add event listeners to restored date selectors
                  daySelect.addEventListener('change', () => autoSave());
                  monthSelect.addEventListener('change', () => autoSave());

                  daySelect.dispatchEvent(new Event('change', { bubbles: true }));
                  monthSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
              }
            });
          }, 300);
        }
      }

      return list;
    }

    // Update position indicators for all lists
    function updateListPositions() {
      const allLists = document.querySelectorAll('.list');
      allLists.forEach((list, index) => {
        const indicator = list.querySelector('.list-position-indicator');
        if (indicator) {
          indicator.textContent = (index + 1).toString();
        }
      });
    }

    // Auto-save function with debouncing to prevent excessive saves
    let saveTimeout;

    function autoSave() {
      // Skip auto-save during drag operations to prevent performance issues
      if (isDragInProgress) {
        console.log('🚫 BLOCKED autoSave during drag operation');
        return;
      }

      console.log('💾 autoSave called - stack trace:', new Error().stack.split('\n')[1]);

      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveToLocalStorage();
        syncToFirebase(); // Re-enabled Firebase sync
      }, 1000); // Save 1 second after last change
    }

    // Firebase sync functions
    let userId = null;
    let isOnline = navigator.onLine;
    let firebaseEnabled = true; // Re-enabled Firebase functionality
    let isClearing = false; // Flag to prevent loading during clear operation

    async function syncToFirebase() {
      if (!firebaseEnabled) {
        console.log('Firebase sync disabled');
        return;
      }

      // Skip Firebase sync during drag operations to prevent performance issues
      if (isDragInProgress) {
        console.log('Skipping Firebase sync during drag operation');
        return;
      }

      console.log('syncToFirebase called - userId:', userId, 'isOnline:', isOnline);
      if (!userId || !isOnline) {
        console.log('Skipping sync - missing userId or offline');
        return;
      }

      try {
        const localData = localStorage.getItem('smartLists');
        console.log('Local data exists:', !!localData);
        if (localData) {
          console.log('Attempting to sync to Firebase...');
          await firebase.firestore()
            .collection('users')
            .doc(userId)
            .set({
              data: localData,
              lastModified: firebase.firestore.FieldValue.serverTimestamp(),
              deviceInfo: {
                userAgent: navigator.userAgent,
                timestamp: Date.now()
              }
            });
          console.log('Synced to Firebase');
        }
      } catch (error) {
        console.error('Firebase sync failed:', error);
      }
    }

    async function loadFromFirebase() {
      if (!userId || isClearing) return false;

      try {
        const doc = await firebase.firestore()
          .collection('users')
          .doc(userId)
          .get();

        if (doc.exists) {
          const firebaseData = doc.data();
          const localData = localStorage.getItem('smartLists');

          // Simple conflict resolution: newer wins
          if (!localData || (firebaseData.lastModified && firebaseData.lastModified.toDate() > new Date(JSON.parse(localData).lastSaved || 0))) {
            localStorage.setItem('smartLists', firebaseData.data);
            console.log('Loaded from Firebase');
            return true;
          }
        }
      } catch (error) {
        console.error('Firebase load failed:', error);
      }
      return false;
    }

    // Mobile item selection functionality
    function initMobileSelection() {
      if (window.innerWidth <= 768) {
        document.addEventListener('click', function (e) {
          const listItem = e.target.closest('.list-item, .list-item-sub');

          if (listItem) {
            // Don't interfere with button clicks, input, or dropdown clicks
            if (e.target.closest('button') || e.target.closest('input') || e.target.closest('select') ||
              e.target.closest('.move-dropdown-menu') || e.target.closest('.list-dropdown-menu')) {
              return;
            }

            // Remove selection from all other items
            document.querySelectorAll('.list-item.mobile-selected, .list-item-sub.mobile-selected').forEach(item => {
              if (item !== listItem) {
                item.classList.remove('mobile-selected');
              }
            });

            // Toggle selection on clicked item
            listItem.classList.toggle('mobile-selected');
          } else {
            // Click outside - remove all selections
            document.querySelectorAll('.list-item.mobile-selected, .list-item-sub.mobile-selected').forEach(item => {
              item.classList.remove('mobile-selected');
            });
          }
        });
      }
    }

    // Initialize Firebase (add this to head)
    function initFirebase() {
      console.log('Starting Firebase auth...');
      // Listen for auth state changes
      firebase.auth().onAuthStateChanged(user => {
        console.log('Auth state changed, user:', user);
        if (user) {
          console.log('User authenticated with UID:', user.uid);
          userId = user.uid;
          loadFromFirebase().then(loaded => {
            if (loaded) {
              // Prevent infinite reload loop
              if (!localStorage.getItem('firebaseLoadedOnce')) {
                localStorage.setItem('firebaseLoadedOnce', 'true');
                console.log('Data loaded from Firebase, reloading page...');
                location.reload();
              } else {
                console.log('Data loaded from Firebase, already reloaded once.');
              }
            } else {
              console.log('No data found in Firebase or local data is newer');
            }
          });
        } else {
          console.log('No authenticated user');
        }
      });
      // Try anonymous sign in
      firebase.auth().signInAnonymously()
        .then(result => {
          console.log('Anonymous sign-in triggered, result:', result);
        })
        .catch(error => {
          console.log('Firebase auth failed, using localStorage only:', error);
        });
    }

    // Masonry layout function for better space utilization
    function applyMasonryLayout() {
      // Prevent masonry on mobile
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        return;
      }

      const container = document.getElementById('list-container');
      const lists = Array.from(container.querySelectorAll('.list:not(.list-dragging):not(.list-ghost)'));

      console.log('🏗️ FINAL MASONRY: Processing lists:', lists.map(l => l.querySelector('.title-input')?.value || 'untitled'));

      if (lists.length === 0) return;

      // Enable masonry mode
      container.classList.add('masonry');

      // Calculate column width and positions
      const containerWidth = container.offsetWidth;
      const gap = 16; // 1rem = 16px
      const columns = 4;
      const columnWidth = (containerWidth - (gap * (columns - 1))) / columns;

      // Track column heights
      const columnHeights = new Array(columns).fill(0);

      lists.forEach((list, index) => {
        // Ensure the list has its natural height first
        list.style.width = columnWidth + 'px';
        list.style.position = 'absolute';

        // Force a reflow to get accurate height
        const listHeight = list.offsetHeight;

        // Find shortest column
        const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));

        // Position the list with proper gaps
        const x = shortestColumn * (columnWidth + gap);
        const y = columnHeights[shortestColumn];

        list.style.left = x + 'px';
        list.style.top = y + 'px';

        // Update column height with gap
        columnHeights[shortestColumn] += listHeight + gap;
      });

      // Set container height
      const maxHeight = Math.max(...columnHeights) - gap; // Remove last gap
      container.style.height = Math.max(maxHeight, 0) + 'px';
    }

    // Function to toggle between grid and masonry layouts
    function toggleMasonryLayout() {
      // Check if we're on mobile
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        alert('Masonry layout is not available on mobile devices. Please use a desktop or tablet for this feature.');
        return;
      }

      const container = document.getElementById('list-container');
      const isMasonry = container.classList.contains('masonry');

      if (isMasonry) {
        // Switch back to grid - AGGRESSIVE RESET
        resetDragState(); // Complete reset of all drag-related state
        container.classList.remove('masonry');
        container.style.height = '';
        container.querySelectorAll('.list').forEach(list => {
          list.style.position = '';
          list.style.left = '';
          list.style.top = '';
          list.style.width = '';
        });
      } else {
        // Switch to masonry
        resetDragState(); // Clean reset before starting masonry
        applyMasonryLayout();
      }
    }

    // Apply masonry layout when lists change
    function refreshLayout() {
      const container = document.getElementById('list-container');
      if (container.classList.contains('masonry') && !container.classList.contains('dragging')) {
        // Use requestAnimationFrame for better performance
        requestAnimationFrame(() => {
          applyMasonryLayout();
        });
      }
    }

    // Improved throttling and debouncing for drag masonry updates
    let dragMasonryTimeout = null;
    let lastGhostPosition = null;
    let dragMasonryDebounce = null;

    // Cleanup function to prevent memory leaks
    function cleanupMasonryTimeouts() {
      if (dragMasonryTimeout) {
        clearTimeout(dragMasonryTimeout);
        dragMasonryTimeout = null;
      }
      if (dragMasonryDebounce) {
        clearTimeout(dragMasonryDebounce);
        dragMasonryDebounce = null;
      }
      lastGhostPosition = null;
    }

    // AGGRESSIVE cleanup function to completely reset drag state
    function resetDragState() {
      cleanupMasonryTimeouts();
      isDragInProgress = false;

      // Clear any remaining drag classes
      const container = document.getElementById('list-container');
      if (container) {
        // Don't remove 'dragging' from container since we don't add it anymore
        container.querySelectorAll('.list-dragging, .list-ghost').forEach(el => {
          el.classList.remove('list-dragging', 'list-ghost');
          el.style.position = '';
          el.style.left = '';
          el.style.top = '';
          el.style.transform = '';
          el.style.zIndex = '';
        });
      }

      document.body.style.cursor = '';
    }

    // Periodic cleanup to prevent memory leaks (runs every 30 seconds)
    setInterval(() => {
      const container = document.getElementById('list-container');
      if (!container || !container.classList.contains('dragging')) {
        cleanupMasonryTimeouts();
      }
    }, 30000);

    // Special masonry layout for during drag operations
    function applyMasonryLayoutDuringDrag() {
      // Prevent masonry on mobile
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        return;
      }

      // Clear any existing timeout to prevent accumulation
      if (dragMasonryDebounce) {
        clearTimeout(dragMasonryDebounce);
        dragMasonryDebounce = null;
      }

      // Aggressive throttling - only update every 200ms during drag to prevent lag
      dragMasonryDebounce = setTimeout(() => {
        dragMasonryDebounce = null;
        performMasonryLayoutDuringDrag();
      }, 200); // Increased to 200ms for much better performance
    }

    // ULTRA-OPTIMIZED masonry layout for drag operations
    let lastOptimizedUpdate = 0;
    let optimizedUpdateTimeout = null;

    function applyMasonryLayoutDuringDragOptimized() {
      // Prevent masonry on mobile
      const isMobile = window.innerWidth <= 768;
      if (isMobile) return;

      const now = Date.now();

      // BALANCED throttling - max 15fps (66ms intervals) for stable feedback
      if (now - lastOptimizedUpdate < 66) {
        return; // Skip this update entirely
      }

      // Clear any pending update
      if (optimizedUpdateTimeout) {
        clearTimeout(optimizedUpdateTimeout);
      }

      // Immediate update for better responsiveness
      optimizedUpdateTimeout = setTimeout(() => {
        lastOptimizedUpdate = Date.now();
        optimizedUpdateTimeout = null;
        performOptimizedMasonryDuringDrag();
      }, 16); // ~60fps for smooth feedback
    }

    // ULTRA-FAST masonry calculation - minimal DOM operations
    function performOptimizedMasonryDuringDrag() {
      const container = document.getElementById('list-container');
      if (!container || !container.classList.contains('masonry')) return;

      // Get all lists including ghost, but exclude dragging element
      const lists = container.querySelectorAll('.list:not(.list-dragging)');
      if (lists.length === 0) return;

      // Cache container dimensions (single DOM read)
      const containerWidth = container.offsetWidth;
      const gap = 16;
      const columns = 4;
      const columnWidth = (containerWidth - (gap * (columns - 1))) / columns;
      const columnHeights = new Array(columns).fill(0);

      // Process all lists in DOM order (this is key for proper ghost positioning)
      const listArray = Array.from(lists);

      console.log('🏗️ Masonry processing order:', listArray.map(l =>
        (l.classList.contains('list-ghost') ? '👻 GHOST' : l.querySelector('.title-input')?.value || 'untitled')
      ));

      listArray.forEach((list, index) => {
        // Set width only once
        if (!list.style.width || list.style.width !== columnWidth + 'px') {
          list.style.width = columnWidth + 'px';
        }

        // Get height (unavoidable DOM read)
        const listHeight = list.offsetHeight;

        // Find shortest column
        const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));

        // Calculate position
        const x = shortestColumn * (columnWidth + gap);
        const y = columnHeights[shortestColumn];

        // Update position immediately - no batching for better responsiveness
        if (list.classList.contains('list-ghost')) {
          // Ghost gets immediate positioning with no transition
          list.style.setProperty('transition', 'none', 'important');
          list.style.setProperty('position', 'absolute', 'important');
          list.style.setProperty('left', x + 'px', 'important');
          list.style.setProperty('top', y + 'px', 'important');
          list.style.setProperty('transform', 'none', 'important');
          // Ghost positioned with !important to override CSS conflicts
        } else {
          // Regular lists get smooth transitions
          list.style.transition = 'all 0.1s ease'; // Faster transition
          list.style.position = 'absolute';
          list.style.left = x + 'px';
          list.style.top = y + 'px';
        }

        // Update column height
        columnHeights[shortestColumn] += listHeight + gap;
      });
    }

    // Actual masonry calculation function - OPTIMIZED for drag performance
    function performMasonryLayoutDuringDrag() {
      const container = document.getElementById('list-container');
      // Include ghost element but exclude dragging element
      const lists = Array.from(container.querySelectorAll('.list:not(.list-dragging)'));

      if (lists.length === 0) return;

      // Calculate column width and positions ONCE
      const containerWidth = container.offsetWidth;
      const gap = 16; // 1rem = 16px
      const columns = 4;
      const columnWidth = (containerWidth - (gap * (columns - 1))) / columns;

      // Track column heights
      const columnHeights = new Array(columns).fill(0);

      // Batch DOM operations for better performance
      const updates = [];

      lists.forEach((list, index) => {
        // Skip if this is the dragging list
        if (list.classList.contains('list-dragging')) return;

        // Batch style changes to reduce reflows
        if (list.style.width !== columnWidth + 'px') {
          list.style.width = columnWidth + 'px';
        }
        if (list.style.position !== 'absolute') {
          list.style.position = 'absolute';
        }

        // Get height (this causes reflow, but we need it)
        const listHeight = list.offsetHeight;

        // Find shortest column
        const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));

        // Calculate position
        const x = shortestColumn * (columnWidth + gap);
        const y = columnHeights[shortestColumn];

        // Store update for batch application
        updates.push({
          list,
          x,
          y,
          isGhost: list.classList.contains('list-ghost')
        });

        // Update column height
        columnHeights[shortestColumn] += listHeight + gap;
      });

      // Apply all position updates in a single batch
      updates.forEach(({ list, x, y, isGhost }) => {
        if (!isGhost) {
          list.style.transition = 'all 0.2s ease'; // Slightly slower for smoother animation during drag
          list.style.left = x + 'px';
          list.style.top = y + 'px';
        } else {
          // Ghost element gets positioned immediately without transition
          list.style.transition = 'none';
          list.style.left = x + 'px';
          list.style.top = y + 'px';
        }
      });

      // Set container height
      const maxHeight = Math.max(...columnHeights) - gap; // Remove last gap
      container.style.height = Math.max(maxHeight, 0) + 'px';
    }

    // Load saved data on page load, or create default list if none exists
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize date display first
      updateDateDisplay();
      // Update every hour (optional - keeps it current if page stays open)
      setInterval(updateDateDisplay, 3600000);

      // Initialize Firebase first, then load data
      initFirebase();
      // Do NOT clear reload flag here
      if (!loadFromLocalStorage()) {
        createList();
      }

      // Initialize mobile selection
      initMobileSelection();

      // Add window resize listener for masonry layout
      window.addEventListener('resize', () => {
        const isMobile = window.innerWidth <= 768;
        const container = document.getElementById('list-container');

        if (isMobile && container.classList.contains('masonry')) {
          // Disable masonry when resizing to mobile
          container.classList.remove('masonry');
          container.style.height = '';
          cleanupMasonryTimeouts(); // Clean up timeouts when disabling masonry
          container.querySelectorAll('.list').forEach(list => {
            list.style.position = '';
            list.style.left = '';
            list.style.top = '';
            list.style.width = '';
          });

          // Update menu button text
          const masonryToggle = document.getElementById('masonry-toggle');
          if (masonryToggle) {
            masonryToggle.textContent = 'Masonry Layout';
          }
        } else if (!isMobile) {
          // Refresh layout on desktop resize
          refreshLayout();
        }
      });
    });
  </script>
</body>

</html>