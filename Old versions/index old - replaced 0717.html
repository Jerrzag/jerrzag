<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@200..700&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <title>Smart List App</title>
  <style>

    #controls button {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 15px;
      color: #000;
      background: #f5ba36;
      border: 0px solid #848484;
      text-align: left;
      transition: background 0.15s;
      position: relative;
      /* box-shadow: rgba(0, 0, 0, 0.15) 0px 4px 16px; */
      border-radius: 0px;
      margin-right: 4px;
    }


    #controls button:hover {
      background: #f0f0f0;
    }

    #style-buttons {
      float:right;
    }

    :root {
      --bg: #ffffff;
      --text: #000000;
      --card: #f4f4f4;
    }
    body.dark {
      --bg: #1a1a1a;
      --text: #f5f5f5;
      --card: #1e1e1e;
    }
    body {
      margin: 0;
      padding: 1rem;
      font-family: "Roboto", sans-serif;
      background-color: var(--bg);
      color: var(--text);
      font-size: 14px;
    }
    #controls {
      margin-bottom: 1rem;
    }
    #list-container {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 1rem;
      position: relative;
    }
    
    /* List size classes */
    .list.size-1 { grid-column: span 1; }
    .list.size-2 { grid-column: span 2; }
    .list.size-3 { grid-column: span 3; }
    .list.size-4 { grid-column: span 4; }
    .list.size-5 { grid-column: span 5; }
    .list {
      background-color: var(--card);
      position: relative;
      padding: 1rem;
      border-radius: 0px;
      min-height: 150px;
      display: flex;
      flex-direction: column;
      animation: fadeInScale 0.3s ease;
      transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
      /* cursor: grab; */
    }
    
    .list.dragging {
      opacity: 0.3;
      cursor: grabbing;
      transition: opacity 0.2s ease;
      z-index: 1000;
    }
    

    .list.style3 {
      background: transparent !important;
    }
    .list.style3 .list-accent,
    .list.style3 .list-vertical-line,
    .list.style3 .list-horizontal-line {
      display: none !important;
    }
    .list.style3 .list-item,
    .list.style3 .list-item-sub {
      border-bottom: none !important;
      background: transparent !important;
      position: relative;
      padding-left: 28px !important;
      margin-bottom: 2px;
      min-height: 28px;
      display: flex;
      align-items: center;
    }
    .list.style3 .list-item::before {
      content: '\2022'; /* bullet */
      position: absolute;
      left: 8px;
      color: #888;
      font-size: 18px;
      line-height: 1;
      transition: color 0.2s;
    }
    .list.style3 .list-item-sub {
      padding-left: 48px !important;
    }
    .list.style3 .list-item-sub::before {
      content: '\25E6'; /* small bullet */
      position: absolute;
      left: 28px;
      color: #bbb;
      font-size: 13px;
      line-height: 1;
      transition: color 0.2s;
    }
    .list.style3 .list-item:hover::before,
    .list.style3 .list-item-sub:hover::before {
      color: #2196f3;
    }
    .list-accent {
      display: none;
      height: 4px;
      width: 100%;
      border-radius: 2px 2px 0 0;
      margin-bottom: -4px;
      transition: background 0.3s;
    }
    @keyframes fadeInScale {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .list.drag-over { outline: 0px dashed #888; }
    .list header {
      display: flex;
      justify-content: space-between;
      margin: 0.25rem 0;
      padding: 0.5rem;
      border-bottom: 1px solid #9996;
    }
    
    .list-item {
      background: transparent;
      padding: 0.5rem;
      border-radius: 0px;
      border-bottom: 1px solid #9996;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .list-item-sub {
      background: transparent;
      padding: 0.5rem;
      border-radius: 0px;
      border-bottom: 1px solid #9996;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-left: 1.5rem;
    }

    .list-item input[type="text"],
    .list-item-sub input[type="text"] {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .list-item:hover {
      border-bottom: 1px solid #444;
    }

    .list-item button {
      max-width: 20px;
      max-height: 20px;
      width: 100%;
      font-size: 0.85rem;
    }

    .list-item-sub:hover {
      border-bottom: 1px solid #444;
    }

    .dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    .input-area {
      min-height: 50px;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    .item-input-cont {
      padding-left: 0.5rem;
      height: 36px;
      border-bottom: 1px solid #9996;
      display: flex;
      align-items: center;
    }

    .item-input-cont:hover {
      border-bottom: 1px solid #444 !important;
    }

    .item-input { width: 100%; height: 100%; }
    input[type="text"] {
      background-color: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-size: 14px;
      font-family: "Roboto", sans-serif;
      width: 100%;
    }

    header input {
    font-size: 22px !important;
    font-weight: 600;
    }

    .list header:hover {
    border-bottom: 1px solid #444;
    }

    input::placeholder { color: #888; }
    .placeholder {
      height: 2.5rem;
      border: 0px dashed #888;
      margin: 0.25rem 0;
      border-radius: 4px;
    }
    .delete-list-btn,
    .delete-item-btn, .list-item-sub-btn,
    .size-btn {
      background-color: transparent;
      border: 0;
      cursor: pointer;
      visibility: hidden;
      opacity: 0;
      transition: opacity 200ms ease-in;
    }
    
    .list header:hover .delete-list-btn,
    .list header:hover .size-btn,
    .list-item:hover .delete-item-btn, .list-item:hover .list-item-sub-btn,
    .list-item-sub:hover .delete-item-btn, .list-item-sub:hover .list-item-sub-btn {
      visibility: visible;
      opacity: 1;
    }

    .edit-item-btn {
      background-color: transparent;
      border: 0;
      cursor: pointer;
      visibility: hidden;
      opacity: 0;
      transition: opacity 200ms ease-in;
      font-size: 14px;
    }

    .list-item:hover .edit-item-btn,
    .list-item-sub:hover .edit-item-btn {
      visibility: visible;
      opacity: 1;
    }

    /* Modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal {
      background-color: var(--bg);
      border-radius: 8px;
      padding: 20px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #999;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 500;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .modal-action-btn {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      transition: background-color 0.2s;
    }

    .modal-action-btn:hover {
      background-color: #e0e0e0;
    }

    .modal-action-btn.delete {
      background-color: #ffebee;
      color: #d32f2f;
    }

    .modal-action-btn.delete:hover {
      background-color: #ffcdd2;
    }

    .modal-content {
      margin-bottom: 20px;
    }

    .modal-input-group {
      margin-bottom: 15px;
    }

    .modal-input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      font-size: 14px;
    }

    .modal-input-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      background-color: var(--bg);
      color: var(--text);
    }

    .modal-input-group input:focus {
      outline: none;
      border-color: #2196f3;
    }

    .sub-items-section {
      margin-top: 15px;
    }

    .sub-items-section h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 500;
    }

    .sub-item-input {
      display: flex;
      gap: 10px;
      margin-bottom: 8px;
      align-items: center;
    }

    .sub-item-input input {
      flex: 1;
    }

    .sub-item-input button {
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
    }

    .sub-item-input button:hover {
      background-color: #d32f2f;
    }

    .add-sub-item-btn {
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
    }

    .add-sub-item-btn:hover {
      background-color: #388e3c;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #999;
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }

    .modal-btn.cancel {
      background-color: #f0f0f0;
      color: #333;
    }

    .modal-btn.cancel:hover {
      background-color: #e0e0e0;
    }

    .modal-btn.save {
      background-color: #2196f3;
      color: white;
    }

    .modal-btn.save:hover {
      background-color: #1976d2;
    }

    .sub-items {
      margin-left: 0;
    }

    .sub-item-input-cont {
      padding-left: 1.5rem;
      height: 36px;
      border-bottom: 1px solid #999;
      display: flex;
      align-items: center;
    }

    .sub-item-input-cont:hover {
      border-bottom: 1px solid #444 !important;
    }

    #listrowstext {
      padding: 0 20px;
    }

    .item-text-ellipsis {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      display: block;
    }

    .item-text-ellipsis-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
      color: inherit;
      background: transparent;
      display: flex;
      align-items: center;
      padding-left: 0.5rem;
    }
    .item-input-overlay-container {
      position: relative;
      flex: 1;
      min-width: 0;
      display: flex;
      align-items: center;
    }

    @media (max-width: 768px) {
      #list-container {
        display: block;
        overflow-x: unset;
        scroll-snap-type: none;
      }
      .list {
        min-width: unset;
        /* width: 100%; */
        flex-shrink: unset;
        scroll-snap-align: unset;
        margin-bottom: 1rem;
      }
      #style-buttons {
        display: none !important;
      }
      #listrowstext, #rowbuttons {
        display: none !important;
      }
    }

    .dropdown-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 15px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
      position: relative;
    }
    .dropdown-item:hover {
      background: #f0f0f0;
    }
    #dropdown-menu {
      background: var(--bg);
      color: var(--text);
    }
    body.dark #dropdown-menu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0,0,0,0.45);
    }
    body.dark .dropdown-item:hover {
      background: #232323;
    }
    .has-submenu:hover .submenu {
      display: block !important;
    }
    .submenu {
      display: none;
      position: absolute;
      min-width: 140px;
      background: var(--bg);
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      border-radius: 8px;
      z-index: 2100;
    }
    .submenu-item {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 15px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
    }
    .submenu-item:hover {
      background: #f0f0f0;
    }
    body.dark .submenu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0,0,0,0.45);
    }
    body.dark .submenu-item:hover {
      background: #232323;
    }

    /* Style 3 timeline look */
    .list.style3 .list-item,
    .list.style3 .list-item-sub {
      border-bottom: none !important;
      background: transparent !important;
      position: relative;
      padding-left: 32px !important;
      margin-bottom: 0px;
      min-height: 28px;
      display: flex;
      align-items: center;
      font-size: 15px;
    }
    .list.style3 .list-item::before {
      content: '\2022'; /* bullet */
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #aaa;
      font-size: 15px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }
    .list.style3 .list-item-sub {
      padding-left: 48px !important;
    }
    .list.style3 .list-item-sub::before {
      content: '\25E6'; /* small bullet */
      position: absolute;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
      color: #ccc;
      font-size: 12px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }
    .list.style3 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 36px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e0e0e0;
      border-radius: 1px;
      z-index: 1;
      display: block;
    }
    .list.style3 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }
    .list.style3 .list-item:hover::before,
    .list.style3 .list-item-sub:hover::before {
      color: #2196f3;
    }
    .list.style3 .list-item input[type="text"],
    .list.style3 .list-item-sub input[type="text"] {
      background: transparent;
      z-index: 3;
    }

    /* Workflowy-style refined */
    .list.style3 .list-item,
    .list.style3 .list-item-sub {
      border-bottom: none !important;
      background: transparent !important;
      position: relative;
      padding-left: 32px !important;
      margin-bottom: 0px;
      min-height: 28px;
      display: flex;
      align-items: center;
      font-size: 15px;
    }
    .list.style3 .list-item::before {
      content: '\2022'; /* bullet */
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #aaa;
      font-size: 15px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }
    .list.style3 .list-item-sub {
      padding-left: 48px !important;
    }
    .list.style3 .list-item-sub::before {
      content: '\25E6'; /* small bullet */
      position: absolute;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
      color: #ccc;
      font-size: 12px;
      line-height: 1;
      transition: color 0.2s;
      z-index: 2;
    }
    .list.style3 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 36px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e0e0e0;
      border-radius: 1px;
      z-index: 1;
      display: block;
    }
    .list.style3 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }
    .list.style3 .list-item:hover::before,
    .list.style3 .list-item-sub:hover::before {
      color: #2196f3;
    }
    .list.style3 .list-item input[type="text"],
    .list.style3 .list-item-sub input[type="text"] {
      background: transparent;
      z-index: 3;
    }
    /* Style 1: Force black text for list content in dark mode */
    body.dark .list.style1,
    body.dark .list.style1 .list-item,
    body.dark .list.style1 .list-item-sub,
    body.dark .list.style1 input[type="text"] {
      color: #000 !important;
    }
    
    /* Style 1 improvements: Add borders and shadows for better definition */
    .list.style1 {
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .list.style1 .list-item,
    .list.style1 .list-item-sub {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .list.style1 .list-item:hover,
    .list.style1 .list-item-sub:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }
    
    /* Override the general hover styles for Style 1 */
    .list.style1 .list-item:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }
    
    .list.style1 .list-item-sub:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
      background-color: rgba(255, 255, 255, 0.1) !important;
    }
    
    .list.style1 header {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .list.style1 .item-input-cont {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .list.style1 .item-input-cont:hover {
      border-bottom: 1px solid rgba(0, 0, 0, 0.2) !important;
    }

    /* Minimal Radial menu styles */
    .radial-menu {
      position: fixed;
      width: 124px;
      height: 124px;
      border-radius: 50%;
      background: #fff;
      border: 1.5px solid #ddd;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: scale(0.95);
      transition: all 0.18s cubic-bezier(.4,0,.2,1);
      z-index: 10000;
      padding: 0;
    }

    .radial-menu-item {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #fff;
      border: 1.5px solid #bbb;
      color: #444;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      user-select: none;
      text-align: center;
      line-height: 1.2;
      padding: 0;
      word-wrap: break-word;
    }
    .radial-menu-item.active {
      background: #f5ba36;
      border-color: #f5ba36;
      color: #000;
    }
    .radial-menu-item:hover:not(.active) {
      background: #e0e0e0;
      border-color: #888;
    }
    body.dark .radial-menu {
      background: #232323;
      border-color: #444;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }
    body.dark .radial-menu-item {
      background: none;
      border-color: #555;
      color: #eee;
    }
    body.dark .radial-menu-item.active {
      background: #333;
      border-color: #fff;
      color: #fff;
    }
    body.dark .radial-menu-item:hover:not(.active) {
      background: #292929;
      border-color: #aaa;
    }
    .radial-menu-item:nth-child(1) { /* Center */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .radial-menu-item:nth-child(2) { /* Down */
      top: 100%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .radial-menu-item:nth-child(3) { /* Up */
      top: 0%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .radial-menu-item:nth-child(4) { /* Left */
      top: 50%;
      left: 0%;
      transform: translate(-50%, -50%);
    }
    .radial-menu-item:nth-child(5) { /* Right */
      top: 50%;
      left: 100%;
      transform: translate(-50%, -50%);
    }
    @media (max-width: 768px) {
      .radial-menu-item:nth-child(1) { /* Center */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .radial-menu-item:nth-child(2) { /* Down */
        top: 100%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .radial-menu-item:nth-child(3) { /* Up */
        top: 0%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    }
    /* List dropdown menu: match main menu style */
    .list-dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 160px;
      background: var(--bg);
      color: var(--text);
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      border-radius: 0px;
      z-index: 3001;
      display: none;
      flex-direction: column;
      padding: 0;
      border: none;
    }
    .list-dropdown-menu.open,
    .list-dropdown-menu[style*='display: flex'] {
      display: block !important;
    }
    .list-dropdown-item {
      display: block;
      width: 100%;
      box-sizing: border-box;
      padding: 12px 20px;
      cursor: pointer;
      font-size: 15px;
      color: var(--text);
      background: none;
      border: none;
      text-align: left;
      transition: background 0.15s;
      position: relative;
      border-radius: 0px;
    }
    .list-dropdown-item:hover {
      background: #f0f0f0;
    }
    .todo-checkbox {
      margin-right: 8px;
      accent-color: #2196f3;
      width: 18px;
      height: 18px;
      vertical-align: middle;
    }
    .todo-completed {
      text-decoration: line-through;
      color: #888;
    }
    body.dark .list-dropdown-menu {
      background: #232323;
      color: var(--text);
      border: 1px solid #333;
      box-shadow: 0 6px 24px rgba(0,0,0,0.45);
    }
    body.dark .list-dropdown-item:hover {
      background: #232323;
    }
    /* Hide 'Cycle size' in list dropdown on mobile */
    @media (max-width: 600px) {
      .list-dropdown-item:first-child { display: none !important; }
      .list-dropdown-menu { min-width: 180px !important; }
    }

    /* Style 1: Vertical line for sub-items (like Style 3, but only for sub-items) */
    .list.style1 .list-item-sub {
      position: relative;
      padding-left: 48px !important;
    }
    .list.style1 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 24px;
      top: -1px;
      bottom: -1px;
      width: 1px;
      background: #000;
      border-radius: 1px;
      z-index: 10;
      display: block;
    }
    .list.style1 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }

    /* Style 2: Vertical line for sub-items (same as Style 1) */
    .list.style2 .list-item-sub {
      position: relative;
      padding-left: 48px !important;
    }
    .list.style2 .list-item-sub::after {
      content: '';
      position: absolute;
      left: 24px;
      top: -1px;
      bottom: -1px;
      width: 1px;
      background: #000;
      border-radius: 1px;
      z-index: 10;
      display: block;
    }
    .list.style2 .sub-items .list-item-sub:last-child::after {
      background: transparent;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <button id="toggle-dark">Toggle Dark Mode</button>
        <button id="add-list">Add List</button>
      </div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <div id="menu-buttons" style="position: relative;">
          <button id="menu-button-top" style="font-size: 22px; padding: 8px 14px;">â‹¯</button>
          <div id="dropdown-menu" style="display: none; position: absolute; top: 100%; right: 0; min-width: 160px; background: var(--bg); box-shadow: 0 4px 16px rgba(0,0,0,0.15); border-radius: 0px; z-index: 2000; overflow: hidden;">
            <div class="dropdown-item">Item 1</div>
            <div class="dropdown-item">Item 2</div>
            <div class="dropdown-item">Item 3</div>
            <div class="dropdown-item">Item 4</div>
            <div class="dropdown-item">Item 5</div>
            <div class="dropdown-item" id="styles-menu-item">Styles â–¸</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="list-container"></div>
  
  <!-- Edit Modal -->
  <div id="edit-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <input type="text" id="modal-item-title" class="modal-title" placeholder="Item text" />
        <div style="display: flex; align-items: center; gap: 8px; margin-left: auto;">
          <button class="modal-action-btn delete" onclick="deleteCurrentItem()">ðŸ—‘ Delete</button>
          <button class="modal-action-btn" onclick="changeItemColor()">ðŸŽ¨ Color</button>
          <button class="modal-action-btn" onclick="showSubOptions()">â‹¯ More</button>
          <button class="modal-close" onclick="closeEditModal()">Ã—</button>
        </div>
      </div>
      
      <div class="modal-actions">
        <button class="modal-action-btn delete" onclick="deleteCurrentItem()">ðŸ—‘ Delete</button>
        <button class="modal-action-btn" onclick="changeItemColor()">ðŸŽ¨ Color</button>
        <button class="modal-action-btn" onclick="showSubOptions()">â‹¯ More</button>
      </div>
      
      <div class="modal-content">
        <div class="sub-items-section">
          <h4>Sub-items:</h4>
          <div id="edit-sub-items-container">
            <!-- Sub-items will be dynamically added here -->
          </div>
          <!-- The always-empty sub-item input will be handled in JS -->
        </div>
      </div>
      
      <div class="modal-footer">
        <button class="modal-btn cancel" onclick="closeEditModal()">Cancel</button>
        <button class="modal-btn save" onclick="saveEditModal()">Save Changes</button>
      </div>
    </div>
  </div>
  
  <!-- Styles submenu, positioned absolutely next to dropdown -->
  <div class="submenu" id="styles-submenu" style="display:none; position: absolute; min-width: 140px; background: var(--bg); box-shadow: 0 4px 16px rgba(0,0,0,0.15); border-radius: 0px; z-index: 2100;">
    <div class="submenu-item" id="style-one">Style 1</div>
    <div class="submenu-item" id="style-two">Style 2</div>
    <div class="submenu-item" id="style-three">Style 3</div>
  </div>
  
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script>
  const container = document.getElementById("list-container");
  const addListBtn = document.getElementById("add-list");
  const toggleDark = document.getElementById("toggle-dark");

  let draggedItem = null;
  const placeholder = document.createElement("div");
  placeholder.className = "placeholder";

  let isMobile = window.innerWidth <= 768;

  let currentStyle = 1; // 1: random color, 2: transparent

  function applyCurrentStyleToAllLists() {
    const lists = document.querySelectorAll('.list');
    lists.forEach(list => {
      // Remove style3 class and timeline lines if present
      list.classList.remove('style3', 'style1', 'style2'); // Remove all style classes first
      const oldVert = list.querySelector('.list-vertical-line');
      if (oldVert) oldVert.remove();
      list.querySelectorAll('.list-horizontal-line').forEach(lh => lh.remove());
      let accent = list.querySelector('.list-accent');
      if (!accent) {
        accent = document.createElement('div');
        accent.className = 'list-accent';
        list.insertBefore(accent, list.firstChild);
      }
      if (currentStyle === 1) {
        list.classList.add('style1'); // Add style1 class for targeting
        // Restore the original color if stored, otherwise assign and store a random color
        if (list.hasAttribute('data-original-bg')) {
          list.style.backgroundColor = list.getAttribute('data-original-bg');
        } else {
          const color = getRandomColor();
          list.setAttribute('data-original-bg', color);
          list.style.backgroundColor = color;
        }
        accent.style.display = 'none';
        // Remove horizontal lines from items
        list.querySelectorAll('.list-horizontal-line').forEach(lh => lh.remove());
      } else if (currentStyle === 2) {
        list.classList.add('style2');
        // Store the original color if not already stored
        if (!list.hasAttribute('data-original-bg')) {
          list.setAttribute('data-original-bg', list.style.backgroundColor);
        }
        list.style.backgroundColor = 'transparent';
        accent.style.display = 'block';
        accent.style.background = list.getAttribute('data-original-bg') || '#ccc';
        // Remove horizontal lines from items
        list.querySelectorAll('.list-horizontal-line').forEach(lh => lh.remove());
      } else if (currentStyle === 3) {
        list.style.backgroundColor = 'transparent';
        accent.style.display = 'none';
        list.classList.add('style3');
      }
    });
  }

  // Style switching logic for submenu
  document.getElementById('style-one').addEventListener('click', function() {
    currentStyle = 1;
    applyCurrentStyleToAllLists();
  });
  document.getElementById('style-two').addEventListener('click', function() {
    currentStyle = 2;
    applyCurrentStyleToAllLists();
  });
  document.getElementById('style-three').addEventListener('click', function() {
    currentStyle = 3;
    applyCurrentStyleToAllLists();
  });

  toggleDark.addEventListener("click", () => {
    document.body.classList.toggle("dark");
  });

  addListBtn.addEventListener("click", () => {
    createList();
  });

  function updateLayoutBasedOnWidth() {
    const width = window.innerWidth;
    const nowMobile = width <= 768;

    if (nowMobile && !isMobile) {
      container.style.gridTemplateColumns = "none";
      isMobile = true;
    } else if (!nowMobile && isMobile) {
      container.style.gridTemplateColumns = "repeat(3, 1fr)";
      isMobile = false;
    }
  }

  window.addEventListener("resize", updateLayoutBasedOnWidth);
  updateLayoutBasedOnWidth();

  function getRandomColor(prevColor = null) {
    const colors = ["#f7d6d0", "#ffb6cb", "#e5e1ea", "#b3d8fa", "#b7e5dd", "#fcf3ab"];
    let availableColors = colors;
    if (prevColor && colors.includes(prevColor)) {
      availableColors = colors.filter(c => c !== prevColor);
    }
    return availableColors[Math.floor(Math.random() * availableColors.length)];
  }

  function createList(color) {
    const list = document.createElement("div");
    list.className = "list";
    // Determine previous list's color if any
    let prevColor = null;
    const lists = document.querySelectorAll('.list');
    if (lists.length > 0) {
      const lastList = lists[lists.length - 1];
      prevColor = lastList.getAttribute('data-original-bg') || lastList.style.backgroundColor;
    }
    // Set background based on current style
    let accent = document.createElement('div');
    accent.className = 'list-accent';
    list.insertBefore(accent, list.firstChild);
    if (currentStyle === 1) {
      const newColor = getRandomColor(prevColor);
      list.setAttribute('data-original-bg', newColor);
      list.style.backgroundColor = newColor;
      accent.style.display = 'none';
    } else if (currentStyle === 2) {
      const newColor = getRandomColor(prevColor);
      list.setAttribute('data-original-bg', newColor);
      list.style.backgroundColor = 'transparent';
      accent.style.display = 'block';
      accent.style.background = newColor;
    } else if (currentStyle === 3) {
      const newColor = getRandomColor(prevColor);
      list.setAttribute('data-original-bg', newColor);
      list.style.backgroundColor = 'transparent';
      accent.style.display = 'none';
      list.classList.add('style3');
    }

    const header = document.createElement("header");
    header.innerHTML = `
      <div style="display: flex; align-items: center; gap: 8px; width: 100%; position: relative;">
        <input type="text" placeholder="List Title" style="flex: 1; padding-right: 40px;" />
        <div style="position: absolute; right: 0; top: 50%; transform: translateY(-50%);">
          <button class="list-menu-btn" type="button" tabindex="0" style="background: none; border: none; font-size: 22px; color: #444; cursor: pointer; display: flex; align-items: center;">
            <span class="material-icons">more_horiz</span>
          </button>
          <div class="list-dropdown-menu" style="display: none; position: absolute; top: 100%; right: 0; min-width: 160px; background: var(--bg); box-shadow: 0 4px 16px rgba(0,0,0,0.15); border-radius: 0px; z-index: 2000; flex-direction: column; padding: 0;">
            <div class="list-dropdown-item">Cycle size</div>
            <div class="list-dropdown-item">Change color</div>
            <div class="list-dropdown-item">Export to text</div>
            <div class="list-dropdown-item">Delete</div>
          </div>
        </div>
      </div>
    `;

    const itemContainer = document.createElement("div");
    itemContainer.className = "items";

    const inputField = document.createElement("input");
    inputField.type = "text";
    inputField.placeholder = "Add item and press Enter";
    inputField.className = "item-input";

    function tryAddItem() {
      const text = inputField.value.trim();
      if (text !== "") {
        const newItem = createItem(text);
        itemContainer.appendChild(newItem);
        inputField.value = "";
      }
    }

    inputField.addEventListener("keydown", (e) => {
      if (e.key === "Enter") tryAddItem();
    });

    inputField.addEventListener("blur", () => tryAddItem());

    const outerInputContainer = document.createElement("div");
    outerInputContainer.className = "input-area";

    const inputWrapper = document.createElement("div");
    inputWrapper.className = "item-input-cont";
    inputWrapper.appendChild(inputField);
    outerInputContainer.appendChild(inputWrapper);

    list.appendChild(header);
    list.appendChild(itemContainer);
    list.appendChild(outerInputContainer);
    container.appendChild(list);

    // Apply current style to the new list
    if (currentStyle === 1) {
      list.classList.add('style1');
    } else if (currentStyle === 2) {
      list.classList.add('style2');
    } else if (currentStyle === 3) {
      list.classList.add('style3');
    }

    addDragListenersForList(list);
  }

function createItem(text = "") {
  const item = document.createElement("div");
  item.className = "list-item";
  item.setAttribute("draggable", true);

  const subContainer = document.createElement("div");
  subContainer.className = "sub-items";

  // Input for editing and display
  const input = document.createElement('input');
  input.type = 'text';
  input.value = text;
  input.className = 'item-input';
  input.title = text;
  input.addEventListener('input', () => { input.title = input.value; });
  item.appendChild(input);

  // Input, +, triangle, and delete buttons
  const plusBtn = document.createElement('button');
  plusBtn.className = 'list-item-sub-btn';
  plusBtn.innerText = '+';
  plusBtn.onclick = function() { addSubItem(item); };
  item.appendChild(plusBtn);
  // Triangle after +
  const triangle = document.createElement("button");
  triangle.className = "expand-collapse-btn";
  triangle.style.marginRight = "0.5rem";
  triangle.style.background = "none";
  triangle.style.border = "none";
  triangle.style.cursor = "pointer";
  triangle.style.display = "none";
  triangle.innerText = "\u25B6";
  triangle.onclick = function(e) {
    e.stopPropagation();
    if (subContainer.style.display === "none") {
      subContainer.style.display = "";
      triangle.innerText = "\u25BC";
    } else {
      subContainer.style.display = "none";
      triangle.innerText = "\u25B6";
    }
  };
  item.appendChild(triangle);
  // Edit button (pen icon)
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-item-btn';
  editBtn.innerHTML = 'âœï¸';
  editBtn.onclick = function() { openEditModal(item); };
  item.appendChild(editBtn);
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-item-btn';
  deleteBtn.innerText = 'ðŸ—‘';
  deleteBtn.onclick = function() {
    item.parentElement.remove();
  };
  item.appendChild(deleteBtn);

  // Initial triangle state: if sub-items exist, show â–¼ and sub-items visible
  function updateTriangleState() {
    if (subContainer.children.length > 0) {
      triangle.style.display = 'inline';
      triangle.innerText = '\u25BC';
      subContainer.style.display = '';
    } else {
      triangle.style.display = 'none';
      subContainer.style.display = '';
    }
  }
  updateTriangleState();
  const subObserver = new MutationObserver(updateTriangleState);
  subObserver.observe(subContainer, { childList: true });
  addDragListenersForItem(item);
  const wrapper = document.createElement("div");
  wrapper.appendChild(item);
  wrapper.appendChild(subContainer);
  return wrapper;
}

function createItemSub(text = "") {
  const item = document.createElement("div");
  item.className = "list-item-sub";
  item.setAttribute("draggable", false);

  // Input for editing and display
  const input = document.createElement('input');
  input.type = 'text';
  input.value = text;
  input.className = 'item-input';
  input.title = text;
  input.placeholder = 'Add sub-item and press Enter';
  input.addEventListener('input', () => { input.title = input.value; });
  item.appendChild(input);

  // Edit button (pen icon) for sub-items
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-item-btn';
  editBtn.innerHTML = 'âœï¸';
  editBtn.onclick = function() { openEditModal(item); };
  item.appendChild(editBtn);
  // Delete button
  const deleteBtn = document.createElement("button");
  deleteBtn.className = "delete-item-btn";
  deleteBtn.innerText = "ðŸ—‘";
  deleteBtn.onclick = function() {
    item.remove();
    ensureOneEmptySubItem(item.parentElement);
  };
  item.appendChild(deleteBtn);
  // Hide edit/delete icons for the always-empty new sub-item input
  function updateIconsVisibility() {
    if (input.value.trim() === "") {
      editBtn.style.display = 'none';
      deleteBtn.style.display = 'none';
    } else {
      editBtn.style.display = '';
      deleteBtn.style.display = '';
    }
  }
  updateIconsVisibility();
  input.addEventListener('input', updateIconsVisibility);
  // Function to add new sub-item if current one has content
  function addNewSubItemIfNeeded(shouldFocus = true) {
    if (input.value.trim() !== "") {
      const subContainer = item.parentElement;
      const newSub = createItemSub("");
      subContainer.appendChild(newSub);
      if (shouldFocus) {
        newSub.querySelector('input').focus();
      }
    }
  }

  // --- Fix: prevent double sub-item creation ---
  let enterPressed = false;

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      enterPressed = true;
      addNewSubItemIfNeeded(true);
      ensureOneEmptySubItem(item.parentElement);
      input.blur();
    }
  });
  input.addEventListener('blur', () => {
    setTimeout(() => {
      const active = document.activeElement;
      // Only skip if focus is moving to another sub-item input in the same sub-items container
      if (
        active &&
        active.classList.contains('item-input') &&
        active.closest('.sub-items') === item.parentElement
      ) {
        // Focus stayed within the same sub-item container, do nothing
        return;
      }
      addNewSubItemIfNeeded(false);
      ensureOneEmptySubItem(item.parentElement);
    }, 0);
  });
  // --- End fix ---

  item.appendChild(input);
  item.appendChild(editBtn);
  item.appendChild(deleteBtn);
  return item;
}

// Helper to ensure exactly one empty sub-item input at the end
function ensureOneEmptySubItem(subContainer) {
  if (!subContainer) return;
  const subItems = Array.from(subContainer.querySelectorAll('.list-item-sub'));
  // Remove all but the last empty sub-item
  let foundEmpty = false;
  for (let i = subItems.length - 1; i >= 0; i--) {
    const inp = subItems[i].querySelector('input');
    if (inp && inp.value.trim() === "") {
      if (!foundEmpty) {
        foundEmpty = true;
      } else {
        subItems[i].remove();
      }
    }
  }
  // If no empty sub-item, add one
  if (!foundEmpty) {
    const newSub = createItemSub("");
    subContainer.appendChild(newSub);
  }
}

function addSubItem(element) {
  let wrapper, subContainer;
  if (element.classList && element.classList.contains('list-item')) {
    wrapper = element.parentElement;
  } else {
    wrapper = element.closest('.list-item').parentElement;
  }
  subContainer = wrapper.querySelector(".sub-items");
  // If last sub-item is not an empty input, add one
  const last = subContainer.lastElementChild;
  if (!last || last.querySelector('input').value !== "") {
    const newSub = createItemSub("");
    subContainer.appendChild(newSub);
    newSub.querySelector('input').focus();
  } else {
    last.querySelector('input').focus();
  }
  ensureOneEmptySubItem(subContainer);
}

  function addDragListenersForItem(item) {
    item.addEventListener("dragstart", () => {
      draggedItem = item.parentElement; // Drag the whole wrapper
      item.parentElement.classList.add("dragging");
    });

    item.addEventListener("dragend", () => {
      item.parentElement.classList.remove("dragging");
      draggedItem = null;
      placeholder.remove();
    });

    item.addEventListener("dragover", (e) => {
      e.preventDefault();
      const container = item.closest(".items");
      if (placeholder.parentElement && placeholder.parentElement !== container) {
        placeholder.remove();
      }
      if (item.parentElement !== placeholder) {
        container.insertBefore(placeholder, item.parentElement);
      }
    });

    item.addEventListener("dragleave", () => {
      item.classList.remove("drag-over");
    });

    item.addEventListener("drop", (e) => {
      e.preventDefault();
      placeholder.remove();
      const container = item.closest(".items");
      const afterElement = getDragAfterElement(container, e.clientY);
      if (afterElement == null) {
        container.appendChild(draggedItem);
      } else {
        container.insertBefore(draggedItem, afterElement);
      }
    });
  }

  function addDragListenersForList(list) {
    const itemContainer = list.querySelector(".items");

    list.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (placeholder.parentElement !== itemContainer) {
        placeholder.remove();
      }

      const afterElement = getDragAfterElement(itemContainer, e.clientY);
      if (afterElement == null) {
        itemContainer.appendChild(placeholder);
      } else {
        itemContainer.insertBefore(placeholder, afterElement);
      }

      list.classList.add("drag-over");
    });

    list.addEventListener("dragleave", () => {
      list.classList.remove("drag-over");
    });

    list.addEventListener("drop", (e) => {
      e.preventDefault();
      list.classList.remove("drag-over");
      placeholder.remove();

      const afterElement = getDragAfterElement(itemContainer, e.clientY);
      if (afterElement == null) {
        itemContainer.appendChild(draggedItem);
      } else {
        itemContainer.insertBefore(draggedItem, afterElement);
      }
    });
  }

  function getDragAfterElement(container, mouseY) {
    const items = [...container.children].filter(child => !child.classList.contains("dragging"));
    return items.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = mouseY - box.top - box.height / 2;
      return offset < 0 && offset > closest.offset
        ? { offset, element: child }
        : closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // Modal functionality
  let currentEditingItem = null;

  // Make functions globally accessible
  window.openEditModal = function(item, originalSubItem = null) {
    // If this is a sub-item, find its parent list-item and open modal for that instead
    if (item.classList.contains('list-item-sub')) {
      originalSubItem = item; // Store the original sub-item that was clicked
      // Navigate up to find the wrapper that contains both list-item and sub-items
      const wrapper = item.parentElement.parentElement;
      const parentListItem = wrapper.querySelector('.list-item');
      if (parentListItem) {
        item = parentListItem;
      }
    }
    
    currentEditingItem = item;
    const modal = document.getElementById('edit-modal');
    const modalItemTitleInput = document.getElementById('modal-item-title');
    const subItemsContainer = document.getElementById('edit-sub-items-container');
    
    // Get the main item text
    const mainInput = item.querySelector('input');
    if (modalItemTitleInput) {
      modalItemTitleInput.value = mainInput.value;
      // Focus the item title input if no sub-item was targeted
      if (!originalSubItem) {
        setTimeout(() => { modalItemTitleInput.focus(); modalItemTitleInput.select(); }, 100);
      }
    }
    // Clear existing sub-items in modal
    subItemsContainer.innerHTML = '';
    
    // Get sub-items if this is a main list item
    if (item.classList.contains('list-item')) {
      const wrapper = item.parentElement;
      const subContainer = wrapper.querySelector('.sub-items');
      if (subContainer) {
        const subItems = subContainer.querySelectorAll('.list-item-sub');
        let targetInput = null; // Track which input to focus
        
        subItems.forEach((subItem, index) => {
          const subInput = subItem.querySelector('input');
          const modalSubItem = addSubItemInputToModal(subInput.value);
          
          // If this is the sub-item that was originally clicked, mark its input for focus
          if (originalSubItem && subItem === originalSubItem) {
            targetInput = modalSubItem.querySelector('input');
          }
        });
        
        // Only add one empty sub-item input at the bottom if needed
        const container = document.getElementById('edit-sub-items-container');
        const lastInput = container.lastElementChild && container.lastElementChild.querySelector('input');
        if (!lastInput || lastInput.value.trim() !== '') {
          addSubItemInputToModal("");
        }
        
        // Show modal first
        modal.style.display = 'flex';
        
        // Use setTimeout to ensure modal is fully displayed before setting focus
        setTimeout(() => {
          if (targetInput) {
            targetInput.focus();
            targetInput.select(); // Also select the text for easy replacement
          } else {
            modalItemTitleInput.focus();
          }
        }, 100);
        
        return; // Exit early since we handled focus
      }
    }
    
    // Show modal for non-list-item cases
    modal.style.display = 'flex';
    
    // Only focus main input if no specific sub-item was targeted
    if (!originalSubItem) {
      modalItemTitleInput.focus();
    }
  };

  window.closeEditModal = function() {
    const modal = document.getElementById('edit-modal');
    modal.style.display = 'none';
    currentEditingItem = null;
  };

  window.addSubItemToModal = function() {
    addSubItemInputToModal('');
  };

  function addSubItemInputToModal(text = '') {
    const container = document.getElementById('edit-sub-items-container');
    // Prevent adding a second empty input if one already exists at the end
    if (text === '' && container.lastElementChild) {
      const lastInput = container.lastElementChild.querySelector('input');
      if (lastInput && lastInput.value.trim() === '') {
        return container.lastElementChild;
      }
    }
    const subItemDiv = document.createElement('div');
    subItemDiv.className = 'sub-item-input';
    const input = document.createElement('input');
    input.type = 'text';
    input.value = text;
    input.placeholder = 'Add sub-item and press Enter';
    const deleteBtn = document.createElement('button');
    deleteBtn.innerText = 'ðŸ—‘';
    deleteBtn.onclick = function() {
      subItemDiv.remove();
      ensureOnlyOneEmptySubItemInput(container);
    };
    subItemDiv.appendChild(input);
    subItemDiv.appendChild(deleteBtn);
    container.appendChild(subItemDiv);
    input.focus();
    // Add Enter key handler to create a new sub-item input below
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        if (input.value.trim() !== '') {
          // Only add a new empty input if the last one is not empty
          const lastInput = container.lastElementChild.querySelector('input');
          if (lastInput && lastInput.value.trim() !== '') {
            addSubItemInputToModal('');
          }
        }
        // After adding, ensure only one empty input at the end
        setTimeout(() => ensureOnlyOneEmptySubItemInput(container), 0);
      }
    });
    // After adding, ensure only one empty input at the end
    setTimeout(() => ensureOnlyOneEmptySubItemInput(container), 0);
    return subItemDiv; // Return the created element
  }

  // Add this helper function for the modal sub-item input
  function ensureOnlyOneEmptySubItemInput(container) {
    const subInputs = Array.from(container.querySelectorAll('.sub-item-input'));
    let foundEmpty = false;
    for (let i = subInputs.length - 1; i >= 0; i--) {
      const inp = subInputs[i].querySelector('input');
      if (inp && inp.value.trim() === '') {
        if (!foundEmpty) {
          foundEmpty = true;
        } else {
          subInputs[i].remove();
        }
      }
    }
  }

  window.saveEditModal = function() {
    if (!currentEditingItem) return;
    
    const mainTextInput = document.getElementById('modal-item-title');
    const subItemsContainer = document.getElementById('edit-sub-items-container');

    // If editing a sub-item directly
    if (currentEditingItem.classList.contains('list-item-sub')) {
      // Only update the sub-item's input value
      const subInputs = subItemsContainer.querySelectorAll('.sub-item-input input');
      // Find the sub-item in the parent list that matches the value before editing
      // (Assume only one sub-item is being edited at a time)
      const parentListItem = currentEditingItem.closest('.list-item');
      if (parentListItem) {
        const wrapper = parentListItem.parentElement;
        const subContainer = wrapper.querySelector('.sub-items');
        const subItems = Array.from(subContainer.querySelectorAll('.list-item-sub'));
        // Find the index of the currentEditingItem among sub-items
        const subIndex = subItems.indexOf(currentEditingItem);
        if (subIndex !== -1 && subInputs[subIndex]) {
          // Update the value of the sub-item's input
          const subInput = currentEditingItem.querySelector('input');
          subInput.value = subInputs[subIndex].value;
        }
      }
      closeEditModal();
      return;
    }

    // Update main item text
    const mainInput = currentEditingItem.querySelector('input');
    mainInput.value = mainTextInput.value;
    
    // Update sub-items if this is a main list item
    if (currentEditingItem.classList.contains('list-item')) {
      const wrapper = currentEditingItem.parentElement;
      const subContainer = wrapper.querySelector('.sub-items');
      if (subContainer) {
        // Clear existing sub-items
        subContainer.innerHTML = '';
        // Add new sub-items from modal
        const subItemInputs = subItemsContainer.querySelectorAll('.sub-item-input input');
        subItemInputs.forEach(input => {
          if (input.value.trim() !== '') {
            const newSub = createItemSub(input.value.trim());
            subContainer.appendChild(newSub);
          }
        });
        // Always ensure one empty sub-item at the end after saving from modal
        ensureOneEmptySubItem(subContainer);
      }
    }
    closeEditModal();
  };

  window.deleteCurrentItem = function() {
    if (!currentEditingItem) return;
    
    if (currentEditingItem.classList.contains('list-item')) {
      // Delete the wrapper that contains the list-item and its sub-items
      const wrapper = currentEditingItem.parentElement;
      wrapper.remove();
      // Don't auto-adjust columns when deleting individual list-items
      // autoAdjustColumns();
    } else {
      currentEditingItem.remove();
    }
    
    closeEditModal();
  };

  window.changeItemColor = function() {
    if (!currentEditingItem) return;
    
    const newColor = getRandomColor();
    if (currentEditingItem.classList.contains('list-item')) {
      const list = currentEditingItem.closest('.list');
      list.style.backgroundColor = newColor;
    }
  };

  window.showSubOptions = function() {
    // Placeholder for future sub-options modal
    alert('Sub-options modal will be implemented here');
  };

  // Close modal when clicking outside
  document.getElementById('edit-modal').addEventListener('click', function(e) {
    if (e.target === this) {
      closeEditModal();
    }
  });

  // Close modal with Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      closeEditModal();
    }
  });

  // Dropdown menu logic
  const menuButton = document.getElementById('menu-button-top');
  const dropdownMenu = document.getElementById('dropdown-menu');
  const stylesMenuItem = document.getElementById('styles-menu-item');
  const stylesSubmenu = document.getElementById('styles-submenu');

  menuButton.addEventListener('click', function(e) {
    e.stopPropagation();
    const isOpen = dropdownMenu.style.display === 'block';
    dropdownMenu.style.display = isOpen ? 'none' : 'block';
    if (stylesSubmenu && isOpen) {
      stylesSubmenu.style.display = 'none';
    }
  });

  // Close menu on outside click (only if click is outside dropdown and submenu)
  document.addEventListener('click', function(e) {
    const dropdownRect = dropdownMenu.getBoundingClientRect();
    let submenuRect = null;
    if (stylesSubmenu && stylesSubmenu.style.display === 'block') {
      submenuRect = stylesSubmenu.getBoundingClientRect();
    }
    const x = e.clientX, y = e.clientY;
    const inDropdown =
      x >= dropdownRect.left && x <= dropdownRect.right &&
      y >= dropdownRect.top && y <= dropdownRect.bottom;
    const inSubmenu = submenuRect &&
      x >= submenuRect.left && x <= submenuRect.right &&
      y >= submenuRect.top && y <= submenuRect.bottom;
    if (!inDropdown && !inSubmenu) {
      dropdownMenu.style.display = 'none';
      if (stylesSubmenu) stylesSubmenu.style.display = 'none';
    }
  });

  // Prevent menu from closing when clicking inside
  dropdownMenu.addEventListener('click', function(e) {
    e.stopPropagation();
  });

  if (stylesMenuItem && stylesSubmenu) {
    stylesMenuItem.addEventListener('click', function(e) {
      e.stopPropagation();
      // Toggle submenu: if open, hide and return
      const isOpen = stylesSubmenu.style.display === 'block';
      if (isOpen) {
        stylesSubmenu.style.display = 'none';
        return;
      }
      // If closed, show it (hidden), measure, position, then show
      const stylesRect = stylesMenuItem.getBoundingClientRect();
      const dropdownRect = dropdownMenu.getBoundingClientRect();
      stylesSubmenu.style.visibility = 'hidden';
      stylesSubmenu.style.display = 'block';
      const submenuWidth = stylesSubmenu.offsetWidth;
      stylesSubmenu.style.top = stylesRect.top + 'px';
      stylesSubmenu.style.left = (dropdownRect.left - submenuWidth) + 'px';
      stylesSubmenu.style.visibility = '';
      stylesSubmenu.style.display = 'block';
    });
    // Hide submenu on submenu item click
    stylesSubmenu.querySelectorAll('.submenu-item').forEach(function(item) {
      item.addEventListener('click', function(e) {
        stylesSubmenu.style.display = 'none';
        dropdownMenu.style.display = 'none';
        // Place your style switching logic here if needed
      });
    });
    // Hide submenu on outside click
    document.addEventListener('click', function(e) {
      if (stylesSubmenu.style.display === 'block') {
        // Check if click is outside submenu and dropdown
        const submenuRect = stylesSubmenu.getBoundingClientRect();
        const dropdownRect = dropdownMenu.getBoundingClientRect();
        const x = e.clientX, y = e.clientY;
        const inDropdown =
          x >= dropdownRect.left && x <= dropdownRect.right &&
          y >= dropdownRect.top && y <= dropdownRect.bottom;
        const inSubmenu =
          x >= submenuRect.left && x <= submenuRect.right &&
          y >= submenuRect.top && y <= submenuRect.bottom;
        if (!inDropdown && !inSubmenu) {
          stylesSubmenu.style.display = 'none';
        }
      }
    });
  }

  // Function to make list smaller
  window.makeListSmaller = function(list) {
    const sizes = ['size-1', 'size-2', 'size-3', 'size-4', 'size-5'];
    let currentSize = 1;
    for (let i = 0; i < sizes.length; i++) {
      if (list.classList.contains(sizes[i])) {
        currentSize = i + 1;
        break;
      }
    }
    sizes.forEach(size => list.classList.remove(size));
    const newSize = Math.max(1, currentSize - 1);
    list.classList.add(`size-${newSize}`);
  };

  // Function to make list larger
  window.makeListLarger = function(list) {
    const sizes = ['size-1', 'size-2', 'size-3', 'size-4', 'size-5'];
    let currentSize = 1;
    for (let i = 0; i < sizes.length; i++) {
      if (list.classList.contains(sizes[i])) {
        currentSize = i + 1;
        break;
      }
    }
    sizes.forEach(size => list.classList.remove(size));
    const newSize = Math.min(5, currentSize + 1);
    list.classList.add(`size-${newSize}`);
  };

  // Start with one list
  createList();

  // On page load, apply current style to the first list
  window.addEventListener('DOMContentLoaded', function() {
    applyCurrentStyleToAllLists();
  });

  // Add this after all lists are rendered and container is defined
  if (!window.listDropdownHandlerAttached) {
    container.addEventListener('click', function(e) {
      // Open/close dropdown
      if (e.target.closest('.list-menu-btn')) {
        e.stopPropagation();
        const btn = e.target.closest('.list-menu-btn');
        const dropdown = btn.parentElement.querySelector('.list-dropdown-menu');
        // Close all other dropdowns first
        document.querySelectorAll('.list-dropdown-menu').forEach(m => {
          if (m !== dropdown) m.style.display = 'none';
        });
        // Toggle this dropdown
        if (dropdown.style.display === 'block' || dropdown.style.display === 'flex') {
          dropdown.style.display = 'none';
          // Remove z-index from parent list
          const parentList = dropdown.closest('.list');
          if (parentList) {
            parentList.style.zIndex = '';
            parentList.style.position = '';
          }
        } else {
          dropdown.style.display = 'block';
          // Bring parent list to front
          const parentList = dropdown.closest('.list');
          if (parentList) {
            parentList.style.zIndex = '3000';
            parentList.style.position = 'relative';
          }
        }
        // Responsive: open left on mobile or if overflowing right
        setTimeout(() => {
          const rect = dropdown.getBoundingClientRect();
          const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
          if (rect.right > vw) {
            dropdown.style.right = 'auto';
            dropdown.style.left = '0';
          } else if (rect.left < 0) {
            dropdown.style.left = '0';
            dropdown.style.right = 'auto';
          } else {
            dropdown.style.right = '0';
            dropdown.style.left = 'auto';
          }
          // Minimum width for mobile
          if (window.innerWidth < 600) {
            dropdown.style.minWidth = '120px';
          } else {
            dropdown.style.minWidth = '160px';
          }
        }, 0);
        return;
      }
      // Dropdown actions
      if (e.target.classList.contains('list-dropdown-item')) {
        e.stopPropagation(); // <-- Ensure menu stays open for click
        const action = e.target.textContent.trim();
        const list = e.target.closest('.list');
        const dropdown = e.target.closest('.list-dropdown-menu');
        if (action === 'Cycle size') {
          // Cycle size classes 1/5, 2/5, 3/5, 4/5, 5/5
          const sizes = ['size-1', 'size-2', 'size-3', 'size-4', 'size-5'];
          let currentIdx = sizes.findIndex(size => list.classList.contains(size));
          let nextIdx;
          if (currentIdx === -1) {
            // If no size class, treat as size-1 and move to size-2
            nextIdx = 1;
          } else {
            nextIdx = (currentIdx + 1) % sizes.length;
          }
          sizes.forEach(size => list.classList.remove(size));
          list.classList.add(sizes[nextIdx]);
        } else if (action === 'Change color') {
          // Cycle through 6 palette colors
          const colors = ["#f7d6d0", "#ffb6cb", "#e5e1ea", "#b3d8fa", "#b7e5dd", "#fcf3ab"];
          let currentColor = list.getAttribute('data-original-bg');
          let idx = colors.indexOf(currentColor);
          idx = (idx + 1) % colors.length;
          const newColor = colors[idx];
          list.setAttribute('data-original-bg', newColor);
          list.style.backgroundColor = newColor;
          const accent = list.querySelector('.list-accent');
          if (accent) accent.style.background = newColor;
        } else if (action === 'Export to text') {
          // Export list title, items, and sub-items as text
          const title = list.querySelector('header input').value || 'Untitled List';
          const items = Array.from(list.querySelectorAll('.list-item input')).map(input => input.value).filter(text => text.trim());
          let exportText = `${title}\n`;
          list.querySelectorAll('.list-item').forEach(item => {
            const itemText = item.querySelector('input').value;
            exportText += `- ${itemText}\n`;
            // Sub-items
            const subItems = item.parentElement.querySelectorAll('.list-item-sub input');
            subItems.forEach(sub => {
              const subText = sub.value;
              if (subText.trim()) exportText += `  - ${subText}\n`;
            });
          });
          const blob = new Blob([exportText], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${title}.txt`;
          a.click();
          URL.revokeObjectURL(url);
        } else if (action === 'Delete') {
          // Show confirmation popup
          const confirmDiv = document.getElementById('list-delete-confirm');
          confirmDiv.style.display = 'block';
          // Centered popup logic
          setTimeout(() => {
            document.getElementById('list-delete-yes').onclick = () => {
              list.remove();
              confirmDiv.style.display = 'none';
            };
            document.getElementById('list-delete-no').onclick = () => {
              confirmDiv.style.display = 'none';
            };
          }, 0);
        }
        if (dropdown) dropdown.style.display = 'none';
        e.stopPropagation();
      }
      // If click is not on a menu or button, close all dropdowns
      document.querySelectorAll('.list-dropdown-menu').forEach(m => {
        m.style.display = 'none';
        const parentList = m.closest('.list');
        if (parentList) {
          parentList.style.zIndex = '';
          parentList.style.position = '';
        }
      });
    });
    document.addEventListener('click', function(e) {
      // If click is outside any open dropdown or button, close all
      if (!e.target.closest('.list-dropdown-menu') && !e.target.closest('.list-menu-btn')) {
        document.querySelectorAll('.list-dropdown-menu').forEach(m => m.style.display = 'none');
      }
    });
    window.listDropdownHandlerAttached = true;
  }

  // Add a minimal confirmation popup to the HTML if not present
  if (!document.getElementById('list-delete-confirm')) {
    const confirmDiv = document.createElement('div');
    confirmDiv.id = 'list-delete-confirm';
    confirmDiv.style.display = 'none';
    confirmDiv.style.position = 'fixed';
    confirmDiv.style.left = '50%';
    confirmDiv.style.top = '50%';
    confirmDiv.style.transform = 'translate(-50%, -50%)';
    confirmDiv.style.background = 'var(--bg)';
    confirmDiv.style.color = 'var(--text)';
    confirmDiv.style.padding = '2rem 2.5rem';
    confirmDiv.style.borderRadius = '12px';
    confirmDiv.style.boxShadow = '0 4px 24px rgba(0,0,0,0.18)';
    confirmDiv.style.zIndex = '9999';
    confirmDiv.innerHTML = `
      <div style="font-size: 1.1em; margin-bottom: 1.2em;">Delete this list?</div>
      <div style="display: flex; gap: 1.5em; justify-content: center;">
        <button id="list-delete-yes" style="background: #f5ba36; color: #000; border: none; padding: 0.5em 1.5em; border-radius: 6px; font-size: 1em; cursor: pointer;">Yes</button>
        <button id="list-delete-no" style="background: #eee; color: #222; border: none; padding: 0.5em 1.5em; border-radius: 6px; font-size: 1em; cursor: pointer;">No</button>
      </div>
    `;
    document.body.appendChild(confirmDiv);
  }

  // Only ONE call to createList() at the end:
  // createList();
  </script>
</body>
</html>